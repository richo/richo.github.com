<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="generator" content="rustdoc">
    <title>The Rust Pointer Guide</title>

    <link rel="stylesheet" type="text/css" href="rust.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico">
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400'
        rel='stylesheet' type='text/css'>

</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="versioninfo">
  <img src="http://www.rust-lang.org/logos/rust-logo-32x32-blk.png" width="32" height="32" alt><br>
  <span class="white-sticker"><a href="http://rust-lang.org">Rust</a> 0.11-pre</span><br>
  <a href="http://github.com/mozilla/rust/commit/1c05eafe98f478cbddde41b839a0c8673cf99554"
    class="hash white-sticker">1c05eafe</a>
</div>


    <h1 class="title">The Rust Pointer Guide</h1>
    <nav id="TOC"><ul>
<li><a href="#you-don&#39;t-actually-need-pointers">1 You don&#39;t actually need pointers</a><ul>
<li><a href="#a-note-for-those-proficient-in-pointers">1.1 A note for those proficient in pointers</a><ul></ul></li></ul></li>
<li><a href="#owned-pointers">2 Owned Pointers</a><ul>
<li><a href="#references-to-traits">2.1 References to Traits</a><ul></ul></li>
<li><a href="#recursive-data-structures">2.2 Recursive Data Structures</a><ul></ul></li>
<li><a href="#efficiency">2.3 Efficiency</a><ul></ul></li></ul></li>
<li><a href="#managed-pointers">3 Managed Pointers</a><ul></ul></li>
<li><a href="#references">4 References</a><ul></ul></li>
<li><a href="#returning-pointers">5 Returning Pointers</a><ul></ul></li>
<li><a href="#related-resources">6 Related Resources</a><ul></ul></li></ul></nav><p>Rust&#39;s pointers are one of its more unique and compelling features. Pointers
are also one of the more confusing topics for newcomers to Rust. They can also
be confusing for people coming from other languages that support pointers, such
as C++. This guide will help you understand this important topic.</p>

<h1 id="you-don&#39;t-actually-need-pointers" class='section-header'><a
                           href="#you-don&#39;t-actually-need-pointers">1 You don&#39;t actually need pointers</a></h1>
<p>I have good news for you: you probably don&#39;t need to care about pointers,
especially as you&#39;re getting started. Think of it this way: Rust is a language
that emphasizes safety. Pointers, as the joke goes, are very pointy: it&#39;s easy
to accidentally stab yourself. Therefore, Rust is made in a way such that you
don&#39;t need them very often.</p>

<p>&quot;But guide!&quot; you may cry. &quot;My co-worker wrote a function that looks like this:</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>succ</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> { <span class='op'>*</span><span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> }
</pre>

<p>So I wrote this code to try it out:</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>number</span> <span class='op'>=</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>succ_number</span> <span class='op'>=</span> <span class='ident'>succ</span>(<span class='ident'>number</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>succ_number</span>);
}
</pre>

<p>And now I get an error:</p>

<pre><code class="language-{.notrust}">error: mismatched types: expected `&amp;int` but found `&lt;VI0&gt;` (expected &amp;-ptr but found integral variable)</code></pre>

<p>What gives? It needs a pointer! Therefore I have to use pointers!&quot;</p>

<p>Turns out, you don&#39;t. All you need is a reference. Try this on for size:</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>number</span> <span class='op'>=</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>succ_number</span> <span class='op'>=</span> <span class='ident'>succ</span>(<span class='kw-2'>&amp;</span><span class='ident'>number</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>succ_number</span>);
}
</pre>

<p>It&#39;s that easy! One extra little <code>&amp;</code> there. This code will run, and print <code>6</code>.</p>

<p>That&#39;s all you need to know. Your co-worker could have written the function
like this:</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>succ</span>(<span class='ident'>x</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> { <span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>number</span> <span class='op'>=</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>succ_number</span> <span class='op'>=</span> <span class='ident'>succ</span>(<span class='ident'>number</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>succ_number</span>);
}
</pre>

<p>No pointers even needed. Then again, this is a simple example. I assume that
your real-world <code>succ</code> function is more complicated, and maybe your co-worker
had a good reason for <code>x</code> to be a pointer of some kind. In that case, references
are your best friend. Don&#39;t worry about it, life is too short.</p>

<p>However.</p>

<p>Here are the use-cases for pointers. I&#39;ve prefixed them with the name of the
pointer that satisfies that use-case:</p>

<ol>
<li>Owned: ~Trait must be a pointer, because you don&#39;t know the size of the
object, so indirection is mandatory.</li>
<li>Owned: You need a recursive data structure. These can be infinite sized, so
indirection is mandatory.</li>
<li>Owned: A very, very, very rare situation in which you have a <em>huge</em> chunk of
data that you wish to pass to many methods. Passing a pointer will make this
more efficient. If you&#39;re coming from another language where this technique is
common, such as C++, please read &quot;A note...&quot; below.</li>
<li>Managed: Having only a single owner to a piece of data would be inconvenient
or impossible. This is only often useful when a program is very large or very
complicated. Using a managed pointer will activate Rust&#39;s garbage collection
mechanism.</li>
<li>Reference: You&#39;re writing a function, and you need a pointer, but you don&#39;t
care about its ownership. If you make the argument a reference, callers
can send in whatever kind they want.</li>
</ol>

<p>Five exceptions. That&#39;s it. Otherwise, you shouldn&#39;t need them. Be sceptical
of pointers in Rust: use them for a deliberate purpose, not just to make the
compiler happy.</p>

<h2 id="a-note-for-those-proficient-in-pointers" class='section-header'><a
                           href="#a-note-for-those-proficient-in-pointers">1.1 A note for those proficient in pointers</a></h2>
<p>If you&#39;re coming to Rust from a language like C or C++, you may be used to
passing things by reference, or passing things by pointer. In some languages,
like Java, you can&#39;t even have objects without a pointer to them. Therefore, if
you were writing this Rust code:</p>
<pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>int</span>,
    <span class='ident'>y</span>: <span class='ident'>int</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>p0</span> <span class='op'>=</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>5</span>, <span class='ident'>y</span>: <span class='number'>10</span>};
    <span class='kw'>let</span> <span class='ident'>p1</span> <span class='op'>=</span> <span class='ident'>transform</span>(<span class='ident'>p0</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>p1</span>);
}
</pre>

<p>I think you&#39;d implement <code>transform</code> like this:</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>transform</span>(<span class='ident'>p</span>: <span class='kw-2'>&amp;</span><span class='ident'>Point</span>) <span class='op'>-&gt;</span> <span class='ident'>Point</span> {
    <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='ident'>p</span>.<span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>, <span class='ident'>y</span>: <span class='ident'>p</span>.<span class='ident'>y</span> <span class='op'>+</span> <span class='number'>1</span>}
}<span class='comment'>

// and change this:
</span><span class='kw'>let</span> <span class='ident'>p1</span> <span class='op'>=</span> <span class='ident'>transform</span>(<span class='kw-2'>&amp;</span><span class='ident'>p0</span>);
</pre>

<p>This does work, but you don&#39;t need to create those references! The better way to write this is simply:</p>
<pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>int</span>,
    <span class='ident'>y</span>: <span class='ident'>int</span>,
}

<span class='kw'>fn</span> <span class='ident'>transform</span>(<span class='ident'>p</span>: <span class='ident'>Point</span>) <span class='op'>-&gt;</span> <span class='ident'>Point</span> {
    <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='ident'>p</span>.<span class='ident'>x</span> <span class='op'>+</span> <span class='number'>1</span>, <span class='ident'>y</span>: <span class='ident'>p</span>.<span class='ident'>y</span> <span class='op'>+</span> <span class='number'>1</span>}
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>p0</span> <span class='op'>=</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>5</span>, <span class='ident'>y</span>: <span class='number'>10</span>};
    <span class='kw'>let</span> <span class='ident'>p1</span> <span class='op'>=</span> <span class='ident'>transform</span>(<span class='ident'>p0</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>p1</span>);
}
</pre>

<p>But won&#39;t this be inefficient? Well, that&#39;s a complicated question, but it&#39;s
important to know that Rust, like C and C++, store aggregate data types
&#39;unboxed,&#39; whereas languages like Java and Ruby store these types as &#39;boxed.&#39;
For smaller structs, this way will be more efficient. For larger ones, it may
be less so. But don&#39;t reach for that pointer until you must! Make sure that the
struct is large enough by performing some tests before you add in the
complexity of pointers.</p>

<h1 id="owned-pointers" class='section-header'><a
                           href="#owned-pointers">2 Owned Pointers</a></h1>
<p>Owned pointers are the conceptually simplest kind of pointer in Rust. A rough
approximation of owned pointers follows:</p>

<ol>
<li>Only one owned pointer may exist to a particular place in memory. It may be
borrowed from that owner, however.</li>
<li>The Rust compiler uses static analysis to determine where the pointer is in
scope, and handles allocating and de-allocating that memory. Owned pointers are
not garbage collected.</li>
</ol>

<p>These two properties make for three use cases.</p>

<h2 id="references-to-traits" class='section-header'><a
                           href="#references-to-traits">2.1 References to Traits</a></h2>
<p>Traits must be referenced through a pointer, because the struct that implements
the trait may be a different size than a different struct that implements the
trait. Therefore, unboxed traits don&#39;t make any sense, and aren&#39;t allowed.</p>

<h2 id="recursive-data-structures" class='section-header'><a
                           href="#recursive-data-structures">2.2 Recursive Data Structures</a></h2>
<p>Sometimes, you need a recursive data structure. The simplest is known as a &#39;cons list&#39;:</p>
<pre class='rust '>

<span class='kw'>enum</span> <span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>Nil</span>,
    <span class='ident'>Cons</span>(<span class='ident'>T</span>, <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span>),
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>list</span>: <span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>Cons</span>(<span class='number'>1</span>, <span class='kw'>box</span> <span class='ident'>Cons</span>(<span class='number'>2</span>, <span class='kw'>box</span> <span class='ident'>Cons</span>(<span class='number'>3</span>, <span class='kw'>box</span> <span class='ident'>Nil</span>)));
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>list</span>);
}
</pre>

<p>This prints:</p>

<pre><code class="language-{.notrust}">Cons(1, box Cons(2, box Cons(3, box Nil)))</code></pre>

<p>The inner lists <em>must</em> be an owned pointer, because we can&#39;t know how many
elements are in the list. Without knowing the length, we don&#39;t know the size,
and therefore require the indirection that pointers offer.</p>

<h2 id="efficiency" class='section-header'><a
                           href="#efficiency">2.3 Efficiency</a></h2>
<p>This should almost never be a concern, but because creating an owned pointer
boxes its value, it therefore makes referring to the value the size of the box.
This may make passing an owned pointer to a function less expensive than
passing the value itself. Don&#39;t worry yourself with this case until you&#39;ve
proved that it&#39;s an issue through benchmarks.</p>

<p>For example, this will work:</p>
<pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>int</span>,
    <span class='ident'>y</span>: <span class='ident'>int</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>10</span>, <span class='ident'>y</span>: <span class='number'>20</span> };
    <span class='ident'>spawn</span>(<span class='kw'>proc</span>() {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span>.<span class='ident'>x</span>);
    });
}
</pre>

<p>This struct is tiny, so it&#39;s fine. If <code>Point</code> were large, this would be more
efficient:</p>
<pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>int</span>,
    <span class='ident'>y</span>: <span class='ident'>int</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>10</span>, <span class='ident'>y</span>: <span class='number'>20</span> };
    <span class='ident'>spawn</span>(<span class='kw'>proc</span>() {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span>.<span class='ident'>x</span>);
    });
}
</pre>

<p>Now it&#39;ll be copying a pointer-sized chunk of memory rather than the whole
struct.</p>

<h1 id="managed-pointers" class='section-header'><a
                           href="#managed-pointers">3 Managed Pointers</a></h1>
<blockquote>
<p><strong>Note</strong>: the <code>@</code> form of managed pointers is deprecated and behind a
feature gate (it requires a <code>#![feature(managed_pointers)]</code> attribute on
the crate root). There are replacements, currently
there is <code>std::rc::Rc</code> and <code>std::gc::Gc</code> for shared ownership via reference
counting and garbage collection respectively.</p>
</blockquote>

<p>Managed pointers, notated by an <code>@</code>, are used when having a single owner for
some data isn&#39;t convenient or possible. This generally happens when your
program is very large and complicated.</p>

<p>For example, let&#39;s say you&#39;re using an owned pointer, and you want to do this:</p>
<pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>int</span>,
    <span class='ident'>y</span>: <span class='ident'>int</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>10</span>, <span class='ident'>y</span>: <span class='number'>20</span> };
    <span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='ident'>a</span>;
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>b</span>.<span class='ident'>x</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span>.<span class='ident'>x</span>);
}
</pre>

<p>You&#39;ll get this error:</p>

<pre><code class="language-{.notrust}">test.rs:10:20: 10:21 error: use of moved value: `a`
test.rs:10     println!(&quot;{}&quot;, a.x);
                              ^
note: in expansion of format_args!
&lt;std-macros&gt;:158:27: 158:81 note: expansion site
&lt;std-macros&gt;:157:5: 159:6 note: in expansion of println!
test.rs:10:5: 10:25 note: expansion site
test.rs:8:9: 8:10 note: `a` moved here because it has type `Box&lt;Point&gt;`, which is moved by default (use `ref` to override)
test.rs:8     let b = a;
                  ^</code></pre>

<p>As the message says, owned pointers only allow for one owner at a time. When you assign <code>a</code> to <code>b</code>, <code>a</code> becomes invalid. Change your code to this, however:</p>
<pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>int</span>,
    <span class='ident'>y</span>: <span class='ident'>int</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='kw-2'>@</span><span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>10</span>, <span class='ident'>y</span>: <span class='number'>20</span> };
    <span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='ident'>a</span>;
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>b</span>.<span class='ident'>x</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span>.<span class='ident'>x</span>);
}
</pre>

<p>And it works:</p>

<pre><code class="language-{.notrust}">10
10</code></pre>

<p>So why not just use managed pointers everywhere? There are two big drawbacks to
managed pointers:</p>

<ol>
<li>They activate Rust&#39;s garbage collector. Other pointer types don&#39;t share this
drawback.</li>
<li>You cannot pass this data to another task. Shared ownership across
concurrency boundaries is the source of endless pain in other languages, so
Rust does not let you do this.</li>
</ol>

<h1 id="references" class='section-header'><a
                           href="#references">4 References</a></h1>
<p>References are the third major kind of pointer Rust supports. They are
simultaneously the simplest and the most complicated kind. Let me explain:
references are considered &#39;borrowed&#39; because they claim no ownership over the
data they&#39;re pointing to. They&#39;re just borrowing it for a while. So in that
sense, they&#39;re simple: just keep whatever ownership the data already has. For
example:</p>
<pre class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>f32</span>,
    <span class='ident'>y</span>: <span class='ident'>f32</span>,
}

<span class='kw'>fn</span> <span class='ident'>compute_distance</span>(<span class='ident'>p1</span>: <span class='kw-2'>&amp;</span><span class='ident'>Point</span>, <span class='ident'>p2</span>: <span class='kw-2'>&amp;</span><span class='ident'>Point</span>) <span class='op'>-&gt;</span> <span class='ident'>f32</span> {
    <span class='kw'>let</span> <span class='ident'>x_d</span> <span class='op'>=</span> <span class='ident'>p1</span>.<span class='ident'>x</span> <span class='op'>-</span> <span class='ident'>p2</span>.<span class='ident'>x</span>;
    <span class='kw'>let</span> <span class='ident'>y_d</span> <span class='op'>=</span> <span class='ident'>p1</span>.<span class='ident'>y</span> <span class='op'>-</span> <span class='ident'>p2</span>.<span class='ident'>y</span>;

    (<span class='ident'>x_d</span> <span class='op'>*</span> <span class='ident'>x_d</span> <span class='op'>+</span> <span class='ident'>y_d</span> <span class='op'>*</span> <span class='ident'>y_d</span>).<span class='ident'>sqrt</span>()
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>origin</span> <span class='op'>=</span>    <span class='kw-2'>@</span><span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>0.0</span>, <span class='ident'>y</span>: <span class='number'>0.0</span> };
    <span class='kw'>let</span> <span class='ident'>p1</span>     <span class='op'>=</span> <span class='kw'>box</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>5.0</span>, <span class='ident'>y</span>: <span class='number'>3.0</span> };

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>compute_distance</span>(<span class='ident'>origin</span>, <span class='ident'>p1</span>));
}
</pre>

<p>This prints <code>5.83095189</code>. You can see that the <code>compute_distance</code> function
takes in two references, but we give it a managed and unique pointer. Of
course, if this were a real program, we wouldn&#39;t have any of these pointers,
they&#39;re just there to demonstrate the concepts.</p>

<p>So how is this hard? Well, because we&#39;re ignoring ownership, the compiler needs
to take great care to make sure that everything is safe. Despite their complete
safety, a reference&#39;s representation at runtime is the same as that of
an ordinary pointer in a C program. They introduce zero overhead. The compiler
does all safety checks at compile time.</p>

<p>This theory is called &#39;region pointers,&#39; and involve a concept called
&#39;lifetimes&#39;. Here&#39;s the simple explanation: would you expect this code to
compile?</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5</span>;
}
</pre>

<p>Probably not. That&#39;s because you know that the name <code>x</code> is valid from where
it&#39;s declared to when it goes out of scope. In this case, that&#39;s the end of
the <code>main</code> function. So you know this code will cause an error. We call this
duration a &#39;lifetime&#39;. Let&#39;s try a more complex example:</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='number'>5</span>;
    <span class='kw'>if</span> <span class='op'>*</span><span class='ident'>x</span> <span class='op'>&lt;</span> <span class='number'>10</span> {
        <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>;
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Oh no: {:?}&quot;</span>, <span class='ident'>y</span>);
        <span class='kw'>return</span>;
    }
    <span class='op'>*</span><span class='ident'>x</span> <span class='op'>-=</span> <span class='number'>1</span>;
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Oh no: {:?}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p>Here, we&#39;re borrowing a pointer to <code>x</code> inside of the <code>if</code>. The compiler, however,
is able to determine that that pointer will go out of scope without <code>x</code> being
mutated, and therefore, lets us pass. This wouldn&#39;t work:</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='number'>5</span>;
    <span class='kw'>if</span> <span class='op'>*</span><span class='ident'>x</span> <span class='op'>&lt;</span> <span class='number'>10</span> {
        <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>;
        <span class='op'>*</span><span class='ident'>x</span> <span class='op'>-=</span> <span class='number'>1</span>;

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Oh no: {:?}&quot;</span>, <span class='ident'>y</span>);
        <span class='kw'>return</span>;
    }
    <span class='op'>*</span><span class='ident'>x</span> <span class='op'>-=</span> <span class='number'>1</span>;
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Oh no: {:?}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p>It gives this error:</p>

<pre><code class="language-{.notrust}">test.rs:5:8: 5:10 error: cannot assign to `*x` because it is borrowed
test.rs:5         *x -= 1;
                  ^~
test.rs:4:16: 4:18 note: borrow of `*x` occurs here
test.rs:4         let y = &amp;x;
                          ^~</code></pre>

<p>As you might guess, this kind of analysis is complex for a human, and therefore
hard for a computer, too! There is an entire <a href="guide-lifetimes.html">guide devoted to references
and lifetimes</a> that goes into lifetimes in
great detail, so if you want the full details, check that out.</p>

<h1 id="returning-pointers" class='section-header'><a
                           href="#returning-pointers">5 Returning Pointers</a></h1>
<p>We&#39;ve talked a lot about functions that accept various kinds of pointers, but
what about returning them? In general, it is better to let the caller decide
how to use a function&#39;s output, instead of assuming a certain type of pointer
is best.</p>

<p>What does that mean? Don&#39;t do this:</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span> {
    <span class='kw'>return</span> <span class='kw'>box</span> <span class='op'>*</span><span class='ident'>x</span>;
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>foo</span>(<span class='ident'>x</span>);
}
</pre>

<p>Do this:</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> {
    <span class='kw'>return</span> <span class='op'>*</span><span class='ident'>x</span>;
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='ident'>foo</span>(<span class='ident'>x</span>);
}
</pre>

<p>This gives you flexibility, without sacrificing performance. For example, this will
also work:</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>foo</span>(<span class='ident'>x</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> {
    <span class='kw'>return</span> <span class='op'>*</span><span class='ident'>x</span>;
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='number'>5</span>;
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>@</span><span class='ident'>foo</span>(<span class='ident'>x</span>);
}
</pre>

<p>You may think that this gives us terrible performance: return a value and then
immediately box it up?!?! Isn&#39;t that the worst of both worlds? Rust is smarter
than that. There is no copy in this code. <code>main</code> allocates enough room for the
<code>@int</code>, passes a pointer to that memory into <code>foo</code> as <code>x</code>, and then <code>foo</code> writes
the value straight into that pointer. This writes the return value directly into
the allocated box.</p>

<p>This is important enough that it bears repeating: pointers are not for optimizing
returning values from your code. Allow the caller to choose how they want to
use your output.</p>

<h1 id="related-resources" class='section-header'><a
                           href="#related-resources">6 Related Resources</a></h1>
<ul>
<li><a href="guide-lifetimes.html">Lifetimes guide</a></li>
</ul>

    <footer><p>
Copyright &copy; 2011-2014 The Rust Project Developers. Licensed under the
<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>
or the <a href="http://opensource.org/licenses/MIT">MIT license</a>, at your option.
</p><p>
This file may not be copied, modified, or distributed except according to those terms.
</p></footer>


</body>
</html>