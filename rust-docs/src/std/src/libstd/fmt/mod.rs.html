<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The std library documentation.">

    <title>mod.rs.html -- source</title>

    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,600'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../../../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico">
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        
            <a href='../../../../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        

        
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content source"><pre class='line-numbers'><span id='1'>   1</span>
<span id='2'>   2</span>
<span id='3'>   3</span>
<span id='4'>   4</span>
<span id='5'>   5</span>
<span id='6'>   6</span>
<span id='7'>   7</span>
<span id='8'>   8</span>
<span id='9'>   9</span>
<span id='10'>  10</span>
<span id='11'>  11</span>
<span id='12'>  12</span>
<span id='13'>  13</span>
<span id='14'>  14</span>
<span id='15'>  15</span>
<span id='16'>  16</span>
<span id='17'>  17</span>
<span id='18'>  18</span>
<span id='19'>  19</span>
<span id='20'>  20</span>
<span id='21'>  21</span>
<span id='22'>  22</span>
<span id='23'>  23</span>
<span id='24'>  24</span>
<span id='25'>  25</span>
<span id='26'>  26</span>
<span id='27'>  27</span>
<span id='28'>  28</span>
<span id='29'>  29</span>
<span id='30'>  30</span>
<span id='31'>  31</span>
<span id='32'>  32</span>
<span id='33'>  33</span>
<span id='34'>  34</span>
<span id='35'>  35</span>
<span id='36'>  36</span>
<span id='37'>  37</span>
<span id='38'>  38</span>
<span id='39'>  39</span>
<span id='40'>  40</span>
<span id='41'>  41</span>
<span id='42'>  42</span>
<span id='43'>  43</span>
<span id='44'>  44</span>
<span id='45'>  45</span>
<span id='46'>  46</span>
<span id='47'>  47</span>
<span id='48'>  48</span>
<span id='49'>  49</span>
<span id='50'>  50</span>
<span id='51'>  51</span>
<span id='52'>  52</span>
<span id='53'>  53</span>
<span id='54'>  54</span>
<span id='55'>  55</span>
<span id='56'>  56</span>
<span id='57'>  57</span>
<span id='58'>  58</span>
<span id='59'>  59</span>
<span id='60'>  60</span>
<span id='61'>  61</span>
<span id='62'>  62</span>
<span id='63'>  63</span>
<span id='64'>  64</span>
<span id='65'>  65</span>
<span id='66'>  66</span>
<span id='67'>  67</span>
<span id='68'>  68</span>
<span id='69'>  69</span>
<span id='70'>  70</span>
<span id='71'>  71</span>
<span id='72'>  72</span>
<span id='73'>  73</span>
<span id='74'>  74</span>
<span id='75'>  75</span>
<span id='76'>  76</span>
<span id='77'>  77</span>
<span id='78'>  78</span>
<span id='79'>  79</span>
<span id='80'>  80</span>
<span id='81'>  81</span>
<span id='82'>  82</span>
<span id='83'>  83</span>
<span id='84'>  84</span>
<span id='85'>  85</span>
<span id='86'>  86</span>
<span id='87'>  87</span>
<span id='88'>  88</span>
<span id='89'>  89</span>
<span id='90'>  90</span>
<span id='91'>  91</span>
<span id='92'>  92</span>
<span id='93'>  93</span>
<span id='94'>  94</span>
<span id='95'>  95</span>
<span id='96'>  96</span>
<span id='97'>  97</span>
<span id='98'>  98</span>
<span id='99'>  99</span>
<span id='100'> 100</span>
<span id='101'> 101</span>
<span id='102'> 102</span>
<span id='103'> 103</span>
<span id='104'> 104</span>
<span id='105'> 105</span>
<span id='106'> 106</span>
<span id='107'> 107</span>
<span id='108'> 108</span>
<span id='109'> 109</span>
<span id='110'> 110</span>
<span id='111'> 111</span>
<span id='112'> 112</span>
<span id='113'> 113</span>
<span id='114'> 114</span>
<span id='115'> 115</span>
<span id='116'> 116</span>
<span id='117'> 117</span>
<span id='118'> 118</span>
<span id='119'> 119</span>
<span id='120'> 120</span>
<span id='121'> 121</span>
<span id='122'> 122</span>
<span id='123'> 123</span>
<span id='124'> 124</span>
<span id='125'> 125</span>
<span id='126'> 126</span>
<span id='127'> 127</span>
<span id='128'> 128</span>
<span id='129'> 129</span>
<span id='130'> 130</span>
<span id='131'> 131</span>
<span id='132'> 132</span>
<span id='133'> 133</span>
<span id='134'> 134</span>
<span id='135'> 135</span>
<span id='136'> 136</span>
<span id='137'> 137</span>
<span id='138'> 138</span>
<span id='139'> 139</span>
<span id='140'> 140</span>
<span id='141'> 141</span>
<span id='142'> 142</span>
<span id='143'> 143</span>
<span id='144'> 144</span>
<span id='145'> 145</span>
<span id='146'> 146</span>
<span id='147'> 147</span>
<span id='148'> 148</span>
<span id='149'> 149</span>
<span id='150'> 150</span>
<span id='151'> 151</span>
<span id='152'> 152</span>
<span id='153'> 153</span>
<span id='154'> 154</span>
<span id='155'> 155</span>
<span id='156'> 156</span>
<span id='157'> 157</span>
<span id='158'> 158</span>
<span id='159'> 159</span>
<span id='160'> 160</span>
<span id='161'> 161</span>
<span id='162'> 162</span>
<span id='163'> 163</span>
<span id='164'> 164</span>
<span id='165'> 165</span>
<span id='166'> 166</span>
<span id='167'> 167</span>
<span id='168'> 168</span>
<span id='169'> 169</span>
<span id='170'> 170</span>
<span id='171'> 171</span>
<span id='172'> 172</span>
<span id='173'> 173</span>
<span id='174'> 174</span>
<span id='175'> 175</span>
<span id='176'> 176</span>
<span id='177'> 177</span>
<span id='178'> 178</span>
<span id='179'> 179</span>
<span id='180'> 180</span>
<span id='181'> 181</span>
<span id='182'> 182</span>
<span id='183'> 183</span>
<span id='184'> 184</span>
<span id='185'> 185</span>
<span id='186'> 186</span>
<span id='187'> 187</span>
<span id='188'> 188</span>
<span id='189'> 189</span>
<span id='190'> 190</span>
<span id='191'> 191</span>
<span id='192'> 192</span>
<span id='193'> 193</span>
<span id='194'> 194</span>
<span id='195'> 195</span>
<span id='196'> 196</span>
<span id='197'> 197</span>
<span id='198'> 198</span>
<span id='199'> 199</span>
<span id='200'> 200</span>
<span id='201'> 201</span>
<span id='202'> 202</span>
<span id='203'> 203</span>
<span id='204'> 204</span>
<span id='205'> 205</span>
<span id='206'> 206</span>
<span id='207'> 207</span>
<span id='208'> 208</span>
<span id='209'> 209</span>
<span id='210'> 210</span>
<span id='211'> 211</span>
<span id='212'> 212</span>
<span id='213'> 213</span>
<span id='214'> 214</span>
<span id='215'> 215</span>
<span id='216'> 216</span>
<span id='217'> 217</span>
<span id='218'> 218</span>
<span id='219'> 219</span>
<span id='220'> 220</span>
<span id='221'> 221</span>
<span id='222'> 222</span>
<span id='223'> 223</span>
<span id='224'> 224</span>
<span id='225'> 225</span>
<span id='226'> 226</span>
<span id='227'> 227</span>
<span id='228'> 228</span>
<span id='229'> 229</span>
<span id='230'> 230</span>
<span id='231'> 231</span>
<span id='232'> 232</span>
<span id='233'> 233</span>
<span id='234'> 234</span>
<span id='235'> 235</span>
<span id='236'> 236</span>
<span id='237'> 237</span>
<span id='238'> 238</span>
<span id='239'> 239</span>
<span id='240'> 240</span>
<span id='241'> 241</span>
<span id='242'> 242</span>
<span id='243'> 243</span>
<span id='244'> 244</span>
<span id='245'> 245</span>
<span id='246'> 246</span>
<span id='247'> 247</span>
<span id='248'> 248</span>
<span id='249'> 249</span>
<span id='250'> 250</span>
<span id='251'> 251</span>
<span id='252'> 252</span>
<span id='253'> 253</span>
<span id='254'> 254</span>
<span id='255'> 255</span>
<span id='256'> 256</span>
<span id='257'> 257</span>
<span id='258'> 258</span>
<span id='259'> 259</span>
<span id='260'> 260</span>
<span id='261'> 261</span>
<span id='262'> 262</span>
<span id='263'> 263</span>
<span id='264'> 264</span>
<span id='265'> 265</span>
<span id='266'> 266</span>
<span id='267'> 267</span>
<span id='268'> 268</span>
<span id='269'> 269</span>
<span id='270'> 270</span>
<span id='271'> 271</span>
<span id='272'> 272</span>
<span id='273'> 273</span>
<span id='274'> 274</span>
<span id='275'> 275</span>
<span id='276'> 276</span>
<span id='277'> 277</span>
<span id='278'> 278</span>
<span id='279'> 279</span>
<span id='280'> 280</span>
<span id='281'> 281</span>
<span id='282'> 282</span>
<span id='283'> 283</span>
<span id='284'> 284</span>
<span id='285'> 285</span>
<span id='286'> 286</span>
<span id='287'> 287</span>
<span id='288'> 288</span>
<span id='289'> 289</span>
<span id='290'> 290</span>
<span id='291'> 291</span>
<span id='292'> 292</span>
<span id='293'> 293</span>
<span id='294'> 294</span>
<span id='295'> 295</span>
<span id='296'> 296</span>
<span id='297'> 297</span>
<span id='298'> 298</span>
<span id='299'> 299</span>
<span id='300'> 300</span>
<span id='301'> 301</span>
<span id='302'> 302</span>
<span id='303'> 303</span>
<span id='304'> 304</span>
<span id='305'> 305</span>
<span id='306'> 306</span>
<span id='307'> 307</span>
<span id='308'> 308</span>
<span id='309'> 309</span>
<span id='310'> 310</span>
<span id='311'> 311</span>
<span id='312'> 312</span>
<span id='313'> 313</span>
<span id='314'> 314</span>
<span id='315'> 315</span>
<span id='316'> 316</span>
<span id='317'> 317</span>
<span id='318'> 318</span>
<span id='319'> 319</span>
<span id='320'> 320</span>
<span id='321'> 321</span>
<span id='322'> 322</span>
<span id='323'> 323</span>
<span id='324'> 324</span>
<span id='325'> 325</span>
<span id='326'> 326</span>
<span id='327'> 327</span>
<span id='328'> 328</span>
<span id='329'> 329</span>
<span id='330'> 330</span>
<span id='331'> 331</span>
<span id='332'> 332</span>
<span id='333'> 333</span>
<span id='334'> 334</span>
<span id='335'> 335</span>
<span id='336'> 336</span>
<span id='337'> 337</span>
<span id='338'> 338</span>
<span id='339'> 339</span>
<span id='340'> 340</span>
<span id='341'> 341</span>
<span id='342'> 342</span>
<span id='343'> 343</span>
<span id='344'> 344</span>
<span id='345'> 345</span>
<span id='346'> 346</span>
<span id='347'> 347</span>
<span id='348'> 348</span>
<span id='349'> 349</span>
<span id='350'> 350</span>
<span id='351'> 351</span>
<span id='352'> 352</span>
<span id='353'> 353</span>
<span id='354'> 354</span>
<span id='355'> 355</span>
<span id='356'> 356</span>
<span id='357'> 357</span>
<span id='358'> 358</span>
<span id='359'> 359</span>
<span id='360'> 360</span>
<span id='361'> 361</span>
<span id='362'> 362</span>
<span id='363'> 363</span>
<span id='364'> 364</span>
<span id='365'> 365</span>
<span id='366'> 366</span>
<span id='367'> 367</span>
<span id='368'> 368</span>
<span id='369'> 369</span>
<span id='370'> 370</span>
<span id='371'> 371</span>
<span id='372'> 372</span>
<span id='373'> 373</span>
<span id='374'> 374</span>
<span id='375'> 375</span>
<span id='376'> 376</span>
<span id='377'> 377</span>
<span id='378'> 378</span>
<span id='379'> 379</span>
<span id='380'> 380</span>
<span id='381'> 381</span>
<span id='382'> 382</span>
<span id='383'> 383</span>
<span id='384'> 384</span>
<span id='385'> 385</span>
<span id='386'> 386</span>
<span id='387'> 387</span>
<span id='388'> 388</span>
<span id='389'> 389</span>
<span id='390'> 390</span>
<span id='391'> 391</span>
<span id='392'> 392</span>
<span id='393'> 393</span>
<span id='394'> 394</span>
<span id='395'> 395</span>
<span id='396'> 396</span>
<span id='397'> 397</span>
<span id='398'> 398</span>
<span id='399'> 399</span>
<span id='400'> 400</span>
<span id='401'> 401</span>
<span id='402'> 402</span>
<span id='403'> 403</span>
<span id='404'> 404</span>
<span id='405'> 405</span>
<span id='406'> 406</span>
<span id='407'> 407</span>
<span id='408'> 408</span>
<span id='409'> 409</span>
<span id='410'> 410</span>
<span id='411'> 411</span>
<span id='412'> 412</span>
<span id='413'> 413</span>
<span id='414'> 414</span>
<span id='415'> 415</span>
<span id='416'> 416</span>
<span id='417'> 417</span>
<span id='418'> 418</span>
<span id='419'> 419</span>
<span id='420'> 420</span>
<span id='421'> 421</span>
<span id='422'> 422</span>
<span id='423'> 423</span>
<span id='424'> 424</span>
<span id='425'> 425</span>
<span id='426'> 426</span>
<span id='427'> 427</span>
<span id='428'> 428</span>
<span id='429'> 429</span>
<span id='430'> 430</span>
<span id='431'> 431</span>
<span id='432'> 432</span>
<span id='433'> 433</span>
<span id='434'> 434</span>
<span id='435'> 435</span>
<span id='436'> 436</span>
<span id='437'> 437</span>
<span id='438'> 438</span>
<span id='439'> 439</span>
<span id='440'> 440</span>
<span id='441'> 441</span>
<span id='442'> 442</span>
<span id='443'> 443</span>
<span id='444'> 444</span>
<span id='445'> 445</span>
<span id='446'> 446</span>
<span id='447'> 447</span>
<span id='448'> 448</span>
<span id='449'> 449</span>
<span id='450'> 450</span>
<span id='451'> 451</span>
<span id='452'> 452</span>
<span id='453'> 453</span>
<span id='454'> 454</span>
<span id='455'> 455</span>
<span id='456'> 456</span>
<span id='457'> 457</span>
<span id='458'> 458</span>
<span id='459'> 459</span>
<span id='460'> 460</span>
<span id='461'> 461</span>
<span id='462'> 462</span>
<span id='463'> 463</span>
<span id='464'> 464</span>
<span id='465'> 465</span>
<span id='466'> 466</span>
<span id='467'> 467</span>
<span id='468'> 468</span>
<span id='469'> 469</span>
<span id='470'> 470</span>
<span id='471'> 471</span>
<span id='472'> 472</span>
<span id='473'> 473</span>
<span id='474'> 474</span>
<span id='475'> 475</span>
<span id='476'> 476</span>
<span id='477'> 477</span>
<span id='478'> 478</span>
<span id='479'> 479</span>
<span id='480'> 480</span>
<span id='481'> 481</span>
<span id='482'> 482</span>
<span id='483'> 483</span>
<span id='484'> 484</span>
<span id='485'> 485</span>
<span id='486'> 486</span>
<span id='487'> 487</span>
<span id='488'> 488</span>
<span id='489'> 489</span>
<span id='490'> 490</span>
<span id='491'> 491</span>
<span id='492'> 492</span>
<span id='493'> 493</span>
<span id='494'> 494</span>
<span id='495'> 495</span>
<span id='496'> 496</span>
<span id='497'> 497</span>
<span id='498'> 498</span>
<span id='499'> 499</span>
<span id='500'> 500</span>
<span id='501'> 501</span>
<span id='502'> 502</span>
<span id='503'> 503</span>
<span id='504'> 504</span>
<span id='505'> 505</span>
<span id='506'> 506</span>
<span id='507'> 507</span>
<span id='508'> 508</span>
<span id='509'> 509</span>
<span id='510'> 510</span>
<span id='511'> 511</span>
<span id='512'> 512</span>
<span id='513'> 513</span>
<span id='514'> 514</span>
<span id='515'> 515</span>
<span id='516'> 516</span>
<span id='517'> 517</span>
<span id='518'> 518</span>
<span id='519'> 519</span>
<span id='520'> 520</span>
<span id='521'> 521</span>
<span id='522'> 522</span>
<span id='523'> 523</span>
<span id='524'> 524</span>
<span id='525'> 525</span>
<span id='526'> 526</span>
<span id='527'> 527</span>
<span id='528'> 528</span>
<span id='529'> 529</span>
<span id='530'> 530</span>
<span id='531'> 531</span>
<span id='532'> 532</span>
<span id='533'> 533</span>
<span id='534'> 534</span>
<span id='535'> 535</span>
<span id='536'> 536</span>
<span id='537'> 537</span>
<span id='538'> 538</span>
<span id='539'> 539</span>
<span id='540'> 540</span>
<span id='541'> 541</span>
<span id='542'> 542</span>
<span id='543'> 543</span>
<span id='544'> 544</span>
<span id='545'> 545</span>
<span id='546'> 546</span>
<span id='547'> 547</span>
<span id='548'> 548</span>
<span id='549'> 549</span>
<span id='550'> 550</span>
<span id='551'> 551</span>
<span id='552'> 552</span>
<span id='553'> 553</span>
<span id='554'> 554</span>
<span id='555'> 555</span>
<span id='556'> 556</span>
<span id='557'> 557</span>
<span id='558'> 558</span>
<span id='559'> 559</span>
<span id='560'> 560</span>
<span id='561'> 561</span>
<span id='562'> 562</span>
<span id='563'> 563</span>
<span id='564'> 564</span>
<span id='565'> 565</span>
<span id='566'> 566</span>
<span id='567'> 567</span>
<span id='568'> 568</span>
<span id='569'> 569</span>
<span id='570'> 570</span>
<span id='571'> 571</span>
<span id='572'> 572</span>
<span id='573'> 573</span>
<span id='574'> 574</span>
<span id='575'> 575</span>
<span id='576'> 576</span>
<span id='577'> 577</span>
<span id='578'> 578</span>
<span id='579'> 579</span>
<span id='580'> 580</span>
<span id='581'> 581</span>
<span id='582'> 582</span>
<span id='583'> 583</span>
<span id='584'> 584</span>
<span id='585'> 585</span>
<span id='586'> 586</span>
<span id='587'> 587</span>
<span id='588'> 588</span>
<span id='589'> 589</span>
<span id='590'> 590</span>
<span id='591'> 591</span>
<span id='592'> 592</span>
<span id='593'> 593</span>
<span id='594'> 594</span>
<span id='595'> 595</span>
<span id='596'> 596</span>
<span id='597'> 597</span>
<span id='598'> 598</span>
<span id='599'> 599</span>
<span id='600'> 600</span>
<span id='601'> 601</span>
<span id='602'> 602</span>
<span id='603'> 603</span>
<span id='604'> 604</span>
<span id='605'> 605</span>
<span id='606'> 606</span>
<span id='607'> 607</span>
<span id='608'> 608</span>
<span id='609'> 609</span>
<span id='610'> 610</span>
<span id='611'> 611</span>
<span id='612'> 612</span>
<span id='613'> 613</span>
<span id='614'> 614</span>
<span id='615'> 615</span>
<span id='616'> 616</span>
<span id='617'> 617</span>
<span id='618'> 618</span>
<span id='619'> 619</span>
<span id='620'> 620</span>
<span id='621'> 621</span>
<span id='622'> 622</span>
<span id='623'> 623</span>
<span id='624'> 624</span>
<span id='625'> 625</span>
<span id='626'> 626</span>
<span id='627'> 627</span>
<span id='628'> 628</span>
<span id='629'> 629</span>
<span id='630'> 630</span>
<span id='631'> 631</span>
<span id='632'> 632</span>
<span id='633'> 633</span>
<span id='634'> 634</span>
<span id='635'> 635</span>
<span id='636'> 636</span>
<span id='637'> 637</span>
<span id='638'> 638</span>
<span id='639'> 639</span>
<span id='640'> 640</span>
<span id='641'> 641</span>
<span id='642'> 642</span>
<span id='643'> 643</span>
<span id='644'> 644</span>
<span id='645'> 645</span>
<span id='646'> 646</span>
<span id='647'> 647</span>
<span id='648'> 648</span>
<span id='649'> 649</span>
<span id='650'> 650</span>
<span id='651'> 651</span>
<span id='652'> 652</span>
<span id='653'> 653</span>
<span id='654'> 654</span>
<span id='655'> 655</span>
<span id='656'> 656</span>
<span id='657'> 657</span>
<span id='658'> 658</span>
<span id='659'> 659</span>
<span id='660'> 660</span>
<span id='661'> 661</span>
<span id='662'> 662</span>
<span id='663'> 663</span>
<span id='664'> 664</span>
<span id='665'> 665</span>
<span id='666'> 666</span>
<span id='667'> 667</span>
<span id='668'> 668</span>
<span id='669'> 669</span>
<span id='670'> 670</span>
<span id='671'> 671</span>
<span id='672'> 672</span>
<span id='673'> 673</span>
<span id='674'> 674</span>
<span id='675'> 675</span>
<span id='676'> 676</span>
<span id='677'> 677</span>
<span id='678'> 678</span>
<span id='679'> 679</span>
<span id='680'> 680</span>
<span id='681'> 681</span>
<span id='682'> 682</span>
<span id='683'> 683</span>
<span id='684'> 684</span>
<span id='685'> 685</span>
<span id='686'> 686</span>
<span id='687'> 687</span>
<span id='688'> 688</span>
<span id='689'> 689</span>
<span id='690'> 690</span>
<span id='691'> 691</span>
<span id='692'> 692</span>
<span id='693'> 693</span>
<span id='694'> 694</span>
<span id='695'> 695</span>
<span id='696'> 696</span>
<span id='697'> 697</span>
<span id='698'> 698</span>
<span id='699'> 699</span>
<span id='700'> 700</span>
<span id='701'> 701</span>
<span id='702'> 702</span>
<span id='703'> 703</span>
<span id='704'> 704</span>
<span id='705'> 705</span>
<span id='706'> 706</span>
<span id='707'> 707</span>
<span id='708'> 708</span>
<span id='709'> 709</span>
<span id='710'> 710</span>
<span id='711'> 711</span>
<span id='712'> 712</span>
<span id='713'> 713</span>
<span id='714'> 714</span>
<span id='715'> 715</span>
<span id='716'> 716</span>
<span id='717'> 717</span>
<span id='718'> 718</span>
<span id='719'> 719</span>
<span id='720'> 720</span>
<span id='721'> 721</span>
<span id='722'> 722</span>
<span id='723'> 723</span>
<span id='724'> 724</span>
<span id='725'> 725</span>
<span id='726'> 726</span>
<span id='727'> 727</span>
<span id='728'> 728</span>
<span id='729'> 729</span>
<span id='730'> 730</span>
<span id='731'> 731</span>
<span id='732'> 732</span>
<span id='733'> 733</span>
<span id='734'> 734</span>
<span id='735'> 735</span>
<span id='736'> 736</span>
<span id='737'> 737</span>
<span id='738'> 738</span>
<span id='739'> 739</span>
<span id='740'> 740</span>
<span id='741'> 741</span>
<span id='742'> 742</span>
<span id='743'> 743</span>
<span id='744'> 744</span>
<span id='745'> 745</span>
<span id='746'> 746</span>
<span id='747'> 747</span>
<span id='748'> 748</span>
<span id='749'> 749</span>
<span id='750'> 750</span>
<span id='751'> 751</span>
<span id='752'> 752</span>
<span id='753'> 753</span>
<span id='754'> 754</span>
<span id='755'> 755</span>
<span id='756'> 756</span>
<span id='757'> 757</span>
<span id='758'> 758</span>
<span id='759'> 759</span>
<span id='760'> 760</span>
<span id='761'> 761</span>
<span id='762'> 762</span>
<span id='763'> 763</span>
<span id='764'> 764</span>
<span id='765'> 765</span>
<span id='766'> 766</span>
<span id='767'> 767</span>
<span id='768'> 768</span>
<span id='769'> 769</span>
<span id='770'> 770</span>
<span id='771'> 771</span>
<span id='772'> 772</span>
<span id='773'> 773</span>
<span id='774'> 774</span>
<span id='775'> 775</span>
<span id='776'> 776</span>
<span id='777'> 777</span>
<span id='778'> 778</span>
<span id='779'> 779</span>
<span id='780'> 780</span>
<span id='781'> 781</span>
<span id='782'> 782</span>
<span id='783'> 783</span>
<span id='784'> 784</span>
<span id='785'> 785</span>
<span id='786'> 786</span>
<span id='787'> 787</span>
<span id='788'> 788</span>
<span id='789'> 789</span>
<span id='790'> 790</span>
<span id='791'> 791</span>
<span id='792'> 792</span>
<span id='793'> 793</span>
<span id='794'> 794</span>
<span id='795'> 795</span>
<span id='796'> 796</span>
<span id='797'> 797</span>
<span id='798'> 798</span>
<span id='799'> 799</span>
<span id='800'> 800</span>
<span id='801'> 801</span>
<span id='802'> 802</span>
<span id='803'> 803</span>
<span id='804'> 804</span>
<span id='805'> 805</span>
<span id='806'> 806</span>
<span id='807'> 807</span>
<span id='808'> 808</span>
<span id='809'> 809</span>
<span id='810'> 810</span>
<span id='811'> 811</span>
<span id='812'> 812</span>
<span id='813'> 813</span>
<span id='814'> 814</span>
<span id='815'> 815</span>
<span id='816'> 816</span>
<span id='817'> 817</span>
<span id='818'> 818</span>
<span id='819'> 819</span>
<span id='820'> 820</span>
<span id='821'> 821</span>
<span id='822'> 822</span>
<span id='823'> 823</span>
<span id='824'> 824</span>
<span id='825'> 825</span>
<span id='826'> 826</span>
<span id='827'> 827</span>
<span id='828'> 828</span>
<span id='829'> 829</span>
<span id='830'> 830</span>
<span id='831'> 831</span>
<span id='832'> 832</span>
<span id='833'> 833</span>
<span id='834'> 834</span>
<span id='835'> 835</span>
<span id='836'> 836</span>
<span id='837'> 837</span>
<span id='838'> 838</span>
<span id='839'> 839</span>
<span id='840'> 840</span>
<span id='841'> 841</span>
<span id='842'> 842</span>
<span id='843'> 843</span>
<span id='844'> 844</span>
<span id='845'> 845</span>
<span id='846'> 846</span>
<span id='847'> 847</span>
<span id='848'> 848</span>
<span id='849'> 849</span>
<span id='850'> 850</span>
<span id='851'> 851</span>
<span id='852'> 852</span>
<span id='853'> 853</span>
<span id='854'> 854</span>
<span id='855'> 855</span>
<span id='856'> 856</span>
<span id='857'> 857</span>
<span id='858'> 858</span>
<span id='859'> 859</span>
<span id='860'> 860</span>
<span id='861'> 861</span>
<span id='862'> 862</span>
<span id='863'> 863</span>
<span id='864'> 864</span>
<span id='865'> 865</span>
<span id='866'> 866</span>
<span id='867'> 867</span>
<span id='868'> 868</span>
<span id='869'> 869</span>
<span id='870'> 870</span>
<span id='871'> 871</span>
<span id='872'> 872</span>
<span id='873'> 873</span>
<span id='874'> 874</span>
<span id='875'> 875</span>
<span id='876'> 876</span>
<span id='877'> 877</span>
<span id='878'> 878</span>
<span id='879'> 879</span>
<span id='880'> 880</span>
<span id='881'> 881</span>
<span id='882'> 882</span>
<span id='883'> 883</span>
<span id='884'> 884</span>
<span id='885'> 885</span>
<span id='886'> 886</span>
<span id='887'> 887</span>
<span id='888'> 888</span>
<span id='889'> 889</span>
<span id='890'> 890</span>
<span id='891'> 891</span>
<span id='892'> 892</span>
<span id='893'> 893</span>
<span id='894'> 894</span>
<span id='895'> 895</span>
<span id='896'> 896</span>
<span id='897'> 897</span>
<span id='898'> 898</span>
<span id='899'> 899</span>
<span id='900'> 900</span>
<span id='901'> 901</span>
<span id='902'> 902</span>
<span id='903'> 903</span>
<span id='904'> 904</span>
<span id='905'> 905</span>
<span id='906'> 906</span>
<span id='907'> 907</span>
<span id='908'> 908</span>
<span id='909'> 909</span>
<span id='910'> 910</span>
<span id='911'> 911</span>
<span id='912'> 912</span>
<span id='913'> 913</span>
<span id='914'> 914</span>
<span id='915'> 915</span>
<span id='916'> 916</span>
<span id='917'> 917</span>
<span id='918'> 918</span>
<span id='919'> 919</span>
<span id='920'> 920</span>
<span id='921'> 921</span>
<span id='922'> 922</span>
<span id='923'> 923</span>
<span id='924'> 924</span>
<span id='925'> 925</span>
<span id='926'> 926</span>
<span id='927'> 927</span>
<span id='928'> 928</span>
<span id='929'> 929</span>
<span id='930'> 930</span>
<span id='931'> 931</span>
<span id='932'> 932</span>
<span id='933'> 933</span>
<span id='934'> 934</span>
<span id='935'> 935</span>
<span id='936'> 936</span>
<span id='937'> 937</span>
<span id='938'> 938</span>
<span id='939'> 939</span>
<span id='940'> 940</span>
<span id='941'> 941</span>
<span id='942'> 942</span>
<span id='943'> 943</span>
<span id='944'> 944</span>
<span id='945'> 945</span>
<span id='946'> 946</span>
<span id='947'> 947</span>
<span id='948'> 948</span>
<span id='949'> 949</span>
<span id='950'> 950</span>
<span id='951'> 951</span>
<span id='952'> 952</span>
<span id='953'> 953</span>
<span id='954'> 954</span>
<span id='955'> 955</span>
<span id='956'> 956</span>
<span id='957'> 957</span>
<span id='958'> 958</span>
<span id='959'> 959</span>
<span id='960'> 960</span>
<span id='961'> 961</span>
<span id='962'> 962</span>
<span id='963'> 963</span>
<span id='964'> 964</span>
<span id='965'> 965</span>
<span id='966'> 966</span>
<span id='967'> 967</span>
<span id='968'> 968</span>
<span id='969'> 969</span>
<span id='970'> 970</span>
<span id='971'> 971</span>
<span id='972'> 972</span>
<span id='973'> 973</span>
<span id='974'> 974</span>
<span id='975'> 975</span>
<span id='976'> 976</span>
<span id='977'> 977</span>
<span id='978'> 978</span>
<span id='979'> 979</span>
<span id='980'> 980</span>
<span id='981'> 981</span>
<span id='982'> 982</span>
<span id='983'> 983</span>
<span id='984'> 984</span>
<span id='985'> 985</span>
<span id='986'> 986</span>
<span id='987'> 987</span>
<span id='988'> 988</span>
<span id='989'> 989</span>
<span id='990'> 990</span>
<span id='991'> 991</span>
<span id='992'> 992</span>
<span id='993'> 993</span>
<span id='994'> 994</span>
<span id='995'> 995</span>
<span id='996'> 996</span>
<span id='997'> 997</span>
<span id='998'> 998</span>
<span id='999'> 999</span>
<span id='1000'>1000</span>
<span id='1001'>1001</span>
<span id='1002'>1002</span>
<span id='1003'>1003</span>
<span id='1004'>1004</span>
<span id='1005'>1005</span>
<span id='1006'>1006</span>
<span id='1007'>1007</span>
<span id='1008'>1008</span>
<span id='1009'>1009</span>
<span id='1010'>1010</span>
<span id='1011'>1011</span>
<span id='1012'>1012</span>
<span id='1013'>1013</span>
<span id='1014'>1014</span>
<span id='1015'>1015</span>
<span id='1016'>1016</span>
<span id='1017'>1017</span>
<span id='1018'>1018</span>
<span id='1019'>1019</span>
<span id='1020'>1020</span>
<span id='1021'>1021</span>
<span id='1022'>1022</span>
<span id='1023'>1023</span>
<span id='1024'>1024</span>
<span id='1025'>1025</span>
<span id='1026'>1026</span>
<span id='1027'>1027</span>
<span id='1028'>1028</span>
<span id='1029'>1029</span>
<span id='1030'>1030</span>
<span id='1031'>1031</span>
<span id='1032'>1032</span>
<span id='1033'>1033</span>
<span id='1034'>1034</span>
<span id='1035'>1035</span>
<span id='1036'>1036</span>
<span id='1037'>1037</span>
<span id='1038'>1038</span>
<span id='1039'>1039</span>
<span id='1040'>1040</span>
<span id='1041'>1041</span>
<span id='1042'>1042</span>
<span id='1043'>1043</span>
<span id='1044'>1044</span>
<span id='1045'>1045</span>
<span id='1046'>1046</span>
<span id='1047'>1047</span>
<span id='1048'>1048</span>
<span id='1049'>1049</span>
<span id='1050'>1050</span>
<span id='1051'>1051</span>
<span id='1052'>1052</span>
<span id='1053'>1053</span>
<span id='1054'>1054</span>
<span id='1055'>1055</span>
<span id='1056'>1056</span>
<span id='1057'>1057</span>
<span id='1058'>1058</span>
<span id='1059'>1059</span>
<span id='1060'>1060</span>
<span id='1061'>1061</span>
<span id='1062'>1062</span>
<span id='1063'>1063</span>
<span id='1064'>1064</span>
<span id='1065'>1065</span>
<span id='1066'>1066</span>
<span id='1067'>1067</span>
<span id='1068'>1068</span>
<span id='1069'>1069</span>
<span id='1070'>1070</span>
<span id='1071'>1071</span>
<span id='1072'>1072</span>
<span id='1073'>1073</span>
<span id='1074'>1074</span>
<span id='1075'>1075</span>
<span id='1076'>1076</span>
<span id='1077'>1077</span>
<span id='1078'>1078</span>
<span id='1079'>1079</span>
<span id='1080'>1080</span>
<span id='1081'>1081</span>
<span id='1082'>1082</span>
<span id='1083'>1083</span>
<span id='1084'>1084</span>
<span id='1085'>1085</span>
<span id='1086'>1086</span>
<span id='1087'>1087</span>
<span id='1088'>1088</span>
<span id='1089'>1089</span>
<span id='1090'>1090</span>
<span id='1091'>1091</span>
<span id='1092'>1092</span>
<span id='1093'>1093</span>
<span id='1094'>1094</span>
<span id='1095'>1095</span>
<span id='1096'>1096</span>
<span id='1097'>1097</span>
<span id='1098'>1098</span>
<span id='1099'>1099</span>
<span id='1100'>1100</span>
<span id='1101'>1101</span>
<span id='1102'>1102</span>
<span id='1103'>1103</span>
<span id='1104'>1104</span>
<span id='1105'>1105</span>
<span id='1106'>1106</span>
<span id='1107'>1107</span>
<span id='1108'>1108</span>
<span id='1109'>1109</span>
<span id='1110'>1110</span>
<span id='1111'>1111</span>
<span id='1112'>1112</span>
<span id='1113'>1113</span>
<span id='1114'>1114</span>
<span id='1115'>1115</span>
<span id='1116'>1116</span>
<span id='1117'>1117</span>
<span id='1118'>1118</span>
<span id='1119'>1119</span>
<span id='1120'>1120</span>
<span id='1121'>1121</span>
<span id='1122'>1122</span>
<span id='1123'>1123</span>
<span id='1124'>1124</span>
<span id='1125'>1125</span>
<span id='1126'>1126</span>
<span id='1127'>1127</span>
<span id='1128'>1128</span>
<span id='1129'>1129</span>
<span id='1130'>1130</span>
<span id='1131'>1131</span>
<span id='1132'>1132</span>
<span id='1133'>1133</span>
<span id='1134'>1134</span>
<span id='1135'>1135</span>
<span id='1136'>1136</span>
<span id='1137'>1137</span>
<span id='1138'>1138</span>
<span id='1139'>1139</span>
<span id='1140'>1140</span>
<span id='1141'>1141</span>
<span id='1142'>1142</span>
<span id='1143'>1143</span>
<span id='1144'>1144</span>
<span id='1145'>1145</span>
<span id='1146'>1146</span>
<span id='1147'>1147</span>
<span id='1148'>1148</span>
<span id='1149'>1149</span>
<span id='1150'>1150</span>
<span id='1151'>1151</span>
<span id='1152'>1152</span>
<span id='1153'>1153</span>
<span id='1154'>1154</span>
<span id='1155'>1155</span>
<span id='1156'>1156</span>
<span id='1157'>1157</span>
<span id='1158'>1158</span>
<span id='1159'>1159</span>
<span id='1160'>1160</span>
<span id='1161'>1161</span>
<span id='1162'>1162</span>
<span id='1163'>1163</span>
<span id='1164'>1164</span>
<span id='1165'>1165</span>
<span id='1166'>1166</span>
<span id='1167'>1167</span>
<span id='1168'>1168</span>
<span id='1169'>1169</span>
<span id='1170'>1170</span>
<span id='1171'>1171</span>
<span id='1172'>1172</span>
<span id='1173'>1173</span>
<span id='1174'>1174</span>
<span id='1175'>1175</span>
<span id='1176'>1176</span>
<span id='1177'>1177</span>
<span id='1178'>1178</span>
<span id='1179'>1179</span>
<span id='1180'>1180</span>
<span id='1181'>1181</span>
<span id='1182'>1182</span>
<span id='1183'>1183</span>
<span id='1184'>1184</span>
<span id='1185'>1185</span>
<span id='1186'>1186</span>
<span id='1187'>1187</span>
<span id='1188'>1188</span>
<span id='1189'>1189</span>
<span id='1190'>1190</span>
<span id='1191'>1191</span>
<span id='1192'>1192</span>
<span id='1193'>1193</span>
<span id='1194'>1194</span>
<span id='1195'>1195</span>
<span id='1196'>1196</span>
<span id='1197'>1197</span>
<span id='1198'>1198</span>
<span id='1199'>1199</span>
<span id='1200'>1200</span>
<span id='1201'>1201</span>
<span id='1202'>1202</span>
<span id='1203'>1203</span>
<span id='1204'>1204</span>
<span id='1205'>1205</span>
<span id='1206'>1206</span>
<span id='1207'>1207</span>
<span id='1208'>1208</span>
<span id='1209'>1209</span>
<span id='1210'>1210</span>
<span id='1211'>1211</span>
<span id='1212'>1212</span>
<span id='1213'>1213</span>
<span id='1214'>1214</span>
<span id='1215'>1215</span>
<span id='1216'>1216</span>
<span id='1217'>1217</span>
<span id='1218'>1218</span>
<span id='1219'>1219</span>
<span id='1220'>1220</span>
<span id='1221'>1221</span>
<span id='1222'>1222</span>
<span id='1223'>1223</span>
<span id='1224'>1224</span>
<span id='1225'>1225</span>
<span id='1226'>1226</span>
<span id='1227'>1227</span>
<span id='1228'>1228</span>
<span id='1229'>1229</span>
<span id='1230'>1230</span>
<span id='1231'>1231</span>
<span id='1232'>1232</span>
<span id='1233'>1233</span>
<span id='1234'>1234</span>
<span id='1235'>1235</span>
<span id='1236'>1236</span>
<span id='1237'>1237</span>
<span id='1238'>1238</span>
<span id='1239'>1239</span>
<span id='1240'>1240</span>
<span id='1241'>1241</span>
<span id='1242'>1242</span>
<span id='1243'>1243</span>
<span id='1244'>1244</span>
<span id='1245'>1245</span>
<span id='1246'>1246</span>
<span id='1247'>1247</span>
<span id='1248'>1248</span>
<span id='1249'>1249</span>
<span id='1250'>1250</span>
<span id='1251'>1251</span>
<span id='1252'>1252</span>
<span id='1253'>1253</span>
<span id='1254'>1254</span>
<span id='1255'>1255</span>
<span id='1256'>1256</span>
<span id='1257'>1257</span>
<span id='1258'>1258</span>
<span id='1259'>1259</span>
<span id='1260'>1260</span>
<span id='1261'>1261</span>
<span id='1262'>1262</span>
<span id='1263'>1263</span>
<span id='1264'>1264</span>
<span id='1265'>1265</span>
<span id='1266'>1266</span>
<span id='1267'>1267</span>
<span id='1268'>1268</span>
<span id='1269'>1269</span>
<span id='1270'>1270</span>
<span id='1271'>1271</span>
<span id='1272'>1272</span>
<span id='1273'>1273</span>
<span id='1274'>1274</span>
<span id='1275'>1275</span>
<span id='1276'>1276</span>
<span id='1277'>1277</span>
<span id='1278'>1278</span>
<span id='1279'>1279</span>
<span id='1280'>1280</span>
<span id='1281'>1281</span>
<span id='1282'>1282</span>
<span id='1283'>1283</span>
<span id='1284'>1284</span>
<span id='1285'>1285</span>
<span id='1286'>1286</span>
<span id='1287'>1287</span>
<span id='1288'>1288</span>
<span id='1289'>1289</span>
<span id='1290'>1290</span>
<span id='1291'>1291</span>
<span id='1292'>1292</span>
<span id='1293'>1293</span>
<span id='1294'>1294</span>
<span id='1295'>1295</span>
<span id='1296'>1296</span>
<span id='1297'>1297</span>
<span id='1298'>1298</span>
<span id='1299'>1299</span>
<span id='1300'>1300</span>
<span id='1301'>1301</span>
<span id='1302'>1302</span>
<span id='1303'>1303</span>
<span id='1304'>1304</span>
<span id='1305'>1305</span>
<span id='1306'>1306</span>
<span id='1307'>1307</span>
<span id='1308'>1308</span>
<span id='1309'>1309</span>
<span id='1310'>1310</span>
<span id='1311'>1311</span>
<span id='1312'>1312</span>
<span id='1313'>1313</span>
<span id='1314'>1314</span>
<span id='1315'>1315</span>
<span id='1316'>1316</span>
<span id='1317'>1317</span>
<span id='1318'>1318</span>
<span id='1319'>1319</span>
<span id='1320'>1320</span>
<span id='1321'>1321</span>
<span id='1322'>1322</span>
<span id='1323'>1323</span>
<span id='1324'>1324</span>
<span id='1325'>1325</span>
<span id='1326'>1326</span>
<span id='1327'>1327</span>
<span id='1328'>1328</span>
<span id='1329'>1329</span>
<span id='1330'>1330</span>
<span id='1331'>1331</span>
<span id='1332'>1332</span>
<span id='1333'>1333</span>
<span id='1334'>1334</span>
<span id='1335'>1335</span>
<span id='1336'>1336</span>
<span id='1337'>1337</span>
<span id='1338'>1338</span>
<span id='1339'>1339</span>
<span id='1340'>1340</span>
<span id='1341'>1341</span>
<span id='1342'>1342</span>
<span id='1343'>1343</span>
<span id='1344'>1344</span>
<span id='1345'>1345</span>
<span id='1346'>1346</span>
<span id='1347'>1347</span>
<span id='1348'>1348</span>
<span id='1349'>1349</span>
<span id='1350'>1350</span>
<span id='1351'>1351</span>
<span id='1352'>1352</span>
<span id='1353'>1353</span>
<span id='1354'>1354</span>
<span id='1355'>1355</span>
<span id='1356'>1356</span>
<span id='1357'>1357</span>
<span id='1358'>1358</span>
<span id='1359'>1359</span>
<span id='1360'>1360</span>
<span id='1361'>1361</span>
<span id='1362'>1362</span>
<span id='1363'>1363</span>
<span id='1364'>1364</span>
<span id='1365'>1365</span>
<span id='1366'>1366</span>
<span id='1367'>1367</span>
<span id='1368'>1368</span>
<span id='1369'>1369</span>
<span id='1370'>1370</span>
<span id='1371'>1371</span>
<span id='1372'>1372</span>
<span id='1373'>1373</span>
<span id='1374'>1374</span>
<span id='1375'>1375</span>
<span id='1376'>1376</span>
<span id='1377'>1377</span>
<span id='1378'>1378</span>
<span id='1379'>1379</span>
<span id='1380'>1380</span>
<span id='1381'>1381</span>
<span id='1382'>1382</span>
<span id='1383'>1383</span>
<span id='1384'>1384</span>
<span id='1385'>1385</span>
<span id='1386'>1386</span>
<span id='1387'>1387</span>
<span id='1388'>1388</span>
</pre><pre class='rust '>
<span class='comment'>// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 &lt;LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0&gt; or the MIT license
// &lt;LICENSE-MIT or http://opensource.org/licenses/MIT&gt;, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

</span><span class='doccomment'>/*!

Utilities for formatting and printing strings

This module contains the runtime support for the `format!` syntax extension.
This macro is implemented in the compiler to emit calls to this module in order
to format arguments at runtime into strings and streams.

The functions contained in this module should not normally be used in everyday
use cases of `format!`. The assumptions made by these functions are unsafe for
all inputs, and the compiler performs a large amount of validation on the
arguments to `format!` in order to ensure safety at runtime. While it is
possible to call these functions directly, it is not recommended to do so in the
general case.

## Usage

The `format!` macro is intended to be familiar to those coming from C&#39;s
printf/fprintf functions or Python&#39;s `str.format` function. In its current
revision, the `format!` macro returns a `~str` type which is the result of the
formatting. In the future it will also be able to pass in a stream to format
arguments directly while performing minimal allocations.

Some examples of the `format!` extension are:

```rust
format!(&quot;Hello&quot;);                 // =&gt; &quot;Hello&quot;.to_owned()
format!(&quot;Hello, {:s}!&quot;, &quot;world&quot;); // =&gt; &quot;Hello, world!&quot;.to_owned()
format!(&quot;The number is {:d}&quot;, 1); // =&gt; &quot;The number is 1&quot;.to_owned()
format!(&quot;{:?}&quot;, ~[3, 4]);         // =&gt; &quot;~[3, 4]&quot;.to_owned()
format!(&quot;{value}&quot;, value=4);      // =&gt; &quot;4&quot;.to_owned()
format!(&quot;{} {}&quot;, 1, 2);           // =&gt; &quot;1 2&quot;.to_owned()
```

From these, you can see that the first argument is a format string. It is
required by the compiler for this to be a string literal; it cannot be a
variable passed in (in order to perform validity checking). The compiler will
then parse the format string and determine if the list of arguments provided is
suitable to pass to this format string.

### Positional parameters

Each formatting argument is allowed to specify which value argument it&#39;s
referencing, and if omitted it is assumed to be &quot;the next argument&quot;. For
example, the format string `{} {} {}` would take three parameters, and they
would be formatted in the same order as they&#39;re given. The format string
`{2} {1} {0}`, however, would format arguments in reverse order.

Things can get a little tricky once you start intermingling the two types of
positional specifiers. The &quot;next argument&quot; specifier can be thought of as an
iterator over the argument. Each time a &quot;next argument&quot; specifier is seen, the
iterator advances. This leads to behavior like this:

```rust
format!(&quot;{1} {} {0} {}&quot;, 1, 2); // =&gt; &quot;2 1 1 2&quot;.to_owned()
```

The internal iterator over the argument has not been advanced by the time the
first `{}` is seen, so it prints the first argument. Then upon reaching the
second `{}`, the iterator has advanced forward to the second argument.
Essentially, parameters which explicitly name their argument do not affect
parameters which do not name an argument in terms of positional specifiers.

A format string is required to use all of its arguments, otherwise it is a
compile-time error. You may refer to the same argument more than once in the
format string, although it must always be referred to with the same type.

### Named parameters

Rust itself does not have a Python-like equivalent of named parameters to a
function, but the `format!` macro is a syntax extension which allows it to
leverage named parameters. Named parameters are listed at the end of the
argument list and have the syntax:

```notrust
identifier &#39;=&#39; expression
```

For example, the following `format!` expressions all use named argument:

```rust
format!(&quot;{argument}&quot;, argument = &quot;test&quot;);       // =&gt; &quot;test&quot;.to_owned()
format!(&quot;{name} {}&quot;, 1, name = 2);              // =&gt; &quot;2 1&quot;.to_owned()
format!(&quot;{a:s} {c:d} {b:?}&quot;, a=&quot;a&quot;, b=(), c=3); // =&gt; &quot;a 3 ()&quot;.to_owned()
```

It is illegal to put positional parameters (those without names) after arguments
which have names. Like positional parameters, it is illegal to provided named
parameters that are unused by the format string.

### Argument types

Each argument&#39;s type is dictated by the format string. It is a requirement that
every argument is only ever referred to by one type. When specifying the format
of an argument, however, a string like `{}` indicates no type. This is allowed,
and if all references to one argument do not provide a type, then the format `?`
is used (the type&#39;s rust-representation is printed). For example, this is an
invalid format string:

```notrust
{0:d} {0:s}
```

Because the first argument is both referred to as an integer as well as a
string.

Because formatting is done via traits, there is no requirement that the
`d` format actually takes an `int`, but rather it simply requires a type which
ascribes to the `Signed` formatting trait. There are various parameters which do
require a particular type, however. Namely if the syntax `{:.*s}` is used, then
the number of characters to print from the string precedes the actual string and
must have the type `uint`. Although a `uint` can be printed with `{:u}`, it is
illegal to reference an argument as such. For example, this is another invalid
format string:

```notrust
{:.*s} {0:u}
```

### Formatting traits

When requesting that an argument be formatted with a particular type, you are
actually requesting that an argument ascribes to a particular trait. This allows
multiple actual types to be formatted via `{:d}` (like `i8` as well as `int`).
The current mapping of types to traits is:

* `?` ⇒ `Poly`
* `d` ⇒ `Signed`
* `i` ⇒ `Signed`
* `u` ⇒ `Unsigned`
* `b` ⇒ `Bool`
* `c` ⇒ `Char`
* `o` ⇒ `Octal`
* `x` ⇒ `LowerHex`
* `X` ⇒ `UpperHex`
* `s` ⇒ `String`
* `p` ⇒ `Pointer`
* `t` ⇒ `Binary`
* `f` ⇒ `Float`
* `e` ⇒ `LowerExp`
* `E` ⇒ `UpperExp`
* *nothing* ⇒ `Show`

What this means is that any type of argument which implements the
`std::fmt::Binary` trait can then be formatted with `{:t}`. Implementations are
provided for these traits for a number of primitive types by the standard
library as well. If no format is specified (as in `{}` or `{:6}`), then the
format trait used is the `Show` trait. This is one of the more commonly
implemented traits when formatting a custom type.

When implementing a format trait for your own type, you will have to implement a
method of the signature:

```rust
# use std;
# mod fmt { pub type Result = (); }
# struct T;
# trait SomeName&lt;T&gt; {
fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; fmt::Result;
# }
```

Your type will be passed as `self` by-reference, and then the function should
emit output into the `f.buf` stream. It is up to each format trait
implementation to correctly adhere to the requested formatting parameters. The
values of these parameters will be listed in the fields of the `Formatter`
struct. In order to help with this, the `Formatter` struct also provides some
helper methods.

Additionally, the return value of this function is `fmt::Result` which is a
typedef to `Result&lt;(), IoError&gt;` (also known as `IoError&lt;()&gt;`). Formatting
implementations should ensure that they return errors from `write!` correctly
(propagating errors upward).

An example of implementing the formatting traits would look
like:

```rust
use std::fmt;
use std::f64;

struct Vector2D {
    x: int,
    y: int,
}

impl fmt::Show for Vector2D {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // The `f.buf` value is of the type `&amp;mut io::Writer`, which is what the
        // write! macro is expecting. Note that this formatting ignores the
        // various flags provided to format strings.
        write!(f.buf, &quot;({}, {})&quot;, self.x, self.y)
    }
}

// Different traits allow different forms of output of a type. The meaning of
// this format is to print the magnitude of a vector.
impl fmt::Binary for Vector2D {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let magnitude = (self.x * self.x + self.y * self.y) as f64;
        let magnitude = magnitude.sqrt();

        // Respect the formatting flags by using the helper method
        // `pad_integral` on the Formatter object. See the method documentation
        // for details, and the function `pad` can be used to pad strings.
        let decimals = f.precision.unwrap_or(3);
        let string = f64::to_str_exact(magnitude, decimals);
        f.pad_integral(true, &quot;&quot;, string.as_bytes())
    }
}

fn main() {
    let myvector = Vector2D { x: 3, y: 4 };

    println!(&quot;{}&quot;, myvector);       // =&gt; &quot;(3, 4)&quot;
    println!(&quot;{:10.3t}&quot;, myvector); // =&gt; &quot;     5.000&quot;
}
```

### Related macros

There are a number of related macros in the `format!` family. The ones that are
currently implemented are:

```ignore
format!      // described above
write!       // first argument is a &amp;mut io::Writer, the destination
writeln!     // same as write but appends a newline
print!       // the format string is printed to the standard output
println!     // same as print but appends a newline
format_args! // described below.
```


#### `write!`

This and `writeln` are two macros which are used to emit the format string to a
specified stream. This is used to prevent intermediate allocations of format
strings and instead directly write the output. Under the hood, this function is
actually invoking the `write` function defined in this module. Example usage is:

```rust
# #![allow(unused_must_use)]
use std::io;

let mut w = io::MemWriter::new();
write!(&amp;mut w as &amp;mut io::Writer, &quot;Hello {}!&quot;, &quot;world&quot;);
```

#### `print!`

This and `println` emit their output to stdout. Similarly to the `write!` macro,
the goal of these macros is to avoid intermediate allocations when printing
output. Example usage is:

```rust
print!(&quot;Hello {}!&quot;, &quot;world&quot;);
println!(&quot;I have a newline {}&quot;, &quot;character at the end&quot;);
```

#### `format_args!`
This is a curious macro which is used to safely pass around
an opaque object describing the format string. This object
does not require any heap allocations to create, and it only
references information on the stack. Under the hood, all of
the related macros are implemented in terms of this. First
off, some example usage is:

```
use std::fmt;
use std::io;

# #[allow(unused_must_use)]
# fn main() {
format_args!(fmt::format, &quot;this returns {}&quot;, &quot;~str&quot;);

let some_writer: &amp;mut io::Writer = &amp;mut io::stdout();
format_args!(|args| { fmt::write(some_writer, args) }, &quot;print with a {}&quot;, &quot;closure&quot;);

fn my_fmt_fn(args: &amp;fmt::Arguments) {
    fmt::write(&amp;mut io::stdout(), args);
}
format_args!(my_fmt_fn, &quot;or a {} too&quot;, &quot;function&quot;);
# }
```

The first argument of the `format_args!` macro is a function (or closure) which
takes one argument of type `&amp;fmt::Arguments`. This structure can then be
passed to the `write` and `format` functions inside this module in order to
process the format string. The goal of this macro is to even further prevent
intermediate allocations when dealing formatting strings.

For example, a logging library could use the standard formatting syntax, but it
would internally pass around this structure until it has been determined where
output should go to.

It is unsafe to programmatically create an instance of `fmt::Arguments` because
the operations performed when executing a format string require the compile-time
checks provided by the compiler. The `format_args!` macro is the only method of
safely creating these structures, but they can be unsafely created with the
constructor provided.

## Internationalization

The formatting syntax supported by the `format!` extension supports
internationalization by providing &quot;methods&quot; which execute various different
outputs depending on the input. The syntax and methods provided are similar to
other internationalization systems, so again nothing should seem alien.
Currently two methods are supported by this extension: &quot;select&quot; and &quot;plural&quot;.

Each method will execute one of a number of clauses, and then the value of the
clause will become what&#39;s the result of the argument&#39;s format. Inside of the
cases, nested argument strings may be provided, but all formatting arguments
must not be done through implicit positional means. All arguments inside of each
case of a method must be explicitly selected by their name or their integer
position.

Furthermore, whenever a case is running, the special character `#` can be used
to reference the string value of the argument which was selected upon. As an
example:

```rust
format!(&quot;{0, select, other{#}}&quot;, &quot;hello&quot;); // =&gt; &quot;hello&quot;.to_owned()
```

This example is the equivalent of `{0:s}` essentially.

### Select

The select method is a switch over a `&amp;str` parameter, and the parameter *must*
be of the type `&amp;str`. An example of the syntax is:

```notrust
{0, select, male{...} female{...} other{...}}
```

Breaking this down, the `0`-th argument is selected upon with the `select`
method, and then a number of cases follow. Each case is preceded by an
identifier which is the match-clause to execute the given arm. In this case,
there are two explicit cases, `male` and `female`. The case will be executed if
the string argument provided is an exact match to the case selected.

The `other` case is also a required case for all `select` methods. This arm will
be executed if none of the other arms matched the word being selected over.

### Plural

The plural method is a switch statement over a `uint` parameter, and the
parameter *must* be a `uint`. A plural method in its full glory can be specified
as:

```notrust
{0, plural, offset=1 =1{...} two{...} many{...} other{...}}
```

To break this down, the first `0` indicates that this method is selecting over
the value of the first positional parameter to the format string. Next, the
`plural` method is being executed. An optionally-supplied `offset` is then given
which indicates a number to subtract from argument `0` when matching. This is
then followed by a list of cases.

Each case is allowed to supply a specific value to match upon with the syntax
`=N`. This case is executed if the value at argument `0` matches N exactly,
without taking the offset into account. A case may also be specified by one of
five keywords: `zero`, `one`, `two`, `few`, and `many`. These cases are matched
on after argument `0` has the offset taken into account. Currently the
definitions of `many` and `few` are hardcoded, but they are in theory defined by
the current locale.

Finally, all `plural` methods must have an `other` case supplied which will be
executed if none of the other cases match.

## Syntax

The syntax for the formatting language used is drawn from other languages, so it
should not be too alien. Arguments are formatted with python-like syntax,
meaning that arguments are surrounded by `{}` instead of the C-like `%`. The
actual grammar for the formatting syntax is:

```notrust
format_string := &lt;text&gt; [ format &lt;text&gt; ] *
format := &#39;{&#39; [ argument ] [ &#39;:&#39; format_spec ] [ &#39;,&#39; function_spec ] &#39;}&#39;
argument := integer | identifier

format_spec := [[fill]align][sign][&#39;#&#39;][0][width][&#39;.&#39; precision][type]
fill := character
align := &#39;&lt;&#39; | &#39;&gt;&#39;
sign := &#39;+&#39; | &#39;-&#39;
width := count
precision := count | &#39;*&#39;
type := identifier | &#39;&#39;
count := parameter | integer
parameter := integer &#39;$&#39;

function_spec := plural | select
select := &#39;select&#39; &#39;,&#39; ( identifier arm ) *
plural := &#39;plural&#39; &#39;,&#39; [ &#39;offset:&#39; integer ] ( selector arm ) *
selector := &#39;=&#39; integer | keyword
keyword := &#39;zero&#39; | &#39;one&#39; | &#39;two&#39; | &#39;few&#39; | &#39;many&#39; | &#39;other&#39;
arm := &#39;{&#39; format_string &#39;}&#39;
```

## Formatting Parameters

Each argument being formatted can be transformed by a number of formatting
parameters (corresponding to `format_spec` in the syntax above). These
parameters affect the string representation of what&#39;s being formatted. This
syntax draws heavily from Python&#39;s, so it may seem a bit familiar.

### Fill/Alignment

The fill character is provided normally in conjunction with the `width`
parameter. This indicates that if the value being formatted is smaller than
`width` some extra characters will be printed around it. The extra characters
are specified by `fill`, and the alignment can be one of two options:

* `&lt;` - the argument is left-aligned in `width` columns
* `&gt;` - the argument is right-aligned in `width` columns

### Sign/#/0

These can all be interpreted as flags for a particular formatter.

* &#39;+&#39; - This is intended for numeric types and indicates that the sign should
        always be printed. Positive signs are never printed by default, and the
        negative sign is only printed by default for the `Signed` trait. This
        flag indicates that the correct sign (+ or -) should always be printed.
* &#39;-&#39; - Currently not used
* &#39;#&#39; - This flag is indicates that the &quot;alternate&quot; form of printing should be
        used. By default, this only applies to the integer formatting traits and
        performs like:
    * `x` - precedes the argument with a &quot;0x&quot;
    * `X` - precedes the argument with a &quot;0x&quot;
    * `t` - precedes the argument with a &quot;0b&quot;
    * `o` - precedes the argument with a &quot;0o&quot;
* &#39;0&#39; - This is used to indicate for integer formats that the padding should
        both be done with a `0` character as well as be sign-aware. A format
        like `{:08d}` would yield `00000001` for the integer `1`, while the same
        format would yield `-0000001` for the integer `-1`. Notice that the
        negative version has one fewer zero than the positive version.

### Width

This is a parameter for the &quot;minimum width&quot; that the format should take up. If
the value&#39;s string does not fill up this many characters, then the padding
specified by fill/alignment will be used to take up the required space.

The default fill/alignment for non-numerics is a space and left-aligned. The
defaults for numeric formatters is also a space but with right-alignment. If the
&#39;0&#39; flag is specified for numerics, then the implicit fill character is &#39;0&#39;.

The value for the width can also be provided as a `uint` in the list of
parameters by using the `2$` syntax indicating that the second argument is a
`uint` specifying the width.

### Precision

For non-numeric types, this can be considered a &quot;maximum width&quot;. If the
resulting string is longer than this width, then it is truncated down to this
many characters and only those are emitted.

For integral types, this has no meaning currently.

For floating-point types, this indicates how many digits after the decimal point
should be printed.

## Escaping

The literal characters `{`, `}`, or `#` may be included in a string by
preceding them with the `\` character. Since `\` is already an
escape character in Rust strings, a string literal using this escape
will look like `&quot;\\{&quot;`.

*/
</span>
<span class='kw'>use</span> <span class='ident'>any</span>;
<span class='kw'>use</span> <span class='ident'>cell</span>::<span class='ident'>Cell</span>;
<span class='kw'>use</span> <span class='ident'>char</span>::<span class='ident'>Char</span>;
<span class='kw'>use</span> <span class='ident'>cmp</span>;
<span class='kw'>use</span> <span class='ident'>container</span>::<span class='ident'>Container</span>;
<span class='kw'>use</span> <span class='ident'>intrinsics</span>::<span class='ident'>TypeId</span>;
<span class='kw'>use</span> <span class='ident'>io</span>::<span class='ident'>MemWriter</span>;
<span class='kw'>use</span> <span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>iter</span>::{<span class='ident'>Iterator</span>, <span class='ident'>range</span>};
<span class='kw'>use</span> <span class='ident'>iter</span>;
<span class='kw'>use</span> <span class='ident'>kinds</span>::<span class='ident'>Copy</span>;
<span class='kw'>use</span> <span class='ident'>mem</span>;
<span class='kw'>use</span> <span class='ident'>num</span>::<span class='ident'>Signed</span>;
<span class='kw'>use</span> <span class='ident'>option</span>::{<span class='prelude-ty'>Option</span>, <span class='prelude-val'>Some</span>, <span class='prelude-val'>None</span>};
<span class='kw'>use</span> <span class='ident'>owned</span>::<span class='ident'>Box</span>;
<span class='kw'>use</span> <span class='ident'>repr</span>;
<span class='kw'>use</span> <span class='ident'>result</span>::{<span class='prelude-val'>Ok</span>, <span class='prelude-val'>Err</span>, <span class='ident'>ResultUnwrap</span>};
<span class='kw'>use</span> <span class='ident'>slice</span>::{<span class='ident'>Vector</span>, <span class='ident'>ImmutableVector</span>};
<span class='kw'>use</span> <span class='ident'>slice</span>;
<span class='kw'>use</span> <span class='ident'>str</span>::{<span class='ident'>StrSlice</span>, <span class='ident'>StrAllocating</span>, <span class='ident'>UTF16Item</span>, <span class='ident'>ScalarValue</span>, <span class='ident'>LoneSurrogate</span>};
<span class='kw'>use</span> <span class='ident'>str</span>;

<span class='kw'>pub</span> <span class='kw'>use</span> <span class='self'>self</span>::<span class='ident'>num</span>::<span class='ident'>radix</span>;
<span class='kw'>pub</span> <span class='kw'>use</span> <span class='self'>self</span>::<span class='ident'>num</span>::<span class='ident'>Radix</span>;
<span class='kw'>pub</span> <span class='kw'>use</span> <span class='self'>self</span>::<span class='ident'>num</span>::<span class='ident'>RadixFmt</span>;

<span class='kw'>mod</span> <span class='ident'>num</span>;
<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>rt</span>;

<span class='kw'>pub</span> <span class='kw'>type</span> <span class='prelude-ty'>Result</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>IoResult</span><span class='op'>&lt;</span>()<span class='op'>&gt;</span>;

<span class='doccomment'>/// A struct to represent both where to emit formatting strings to and how they
</span><span class='doccomment'>/// should be formatted. A mutable version of this is passed to all formatting
</span><span class='doccomment'>/// traits.
</span><span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Formatter</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='doccomment'>/// Flags for formatting (packed version of rt::Flag)
</span>    <span class='kw'>pub</span> <span class='ident'>flags</span>: <span class='ident'>uint</span>,
    <span class='doccomment'>/// Character used as &#39;fill&#39; whenever there is alignment
</span>    <span class='kw'>pub</span> <span class='ident'>fill</span>: <span class='ident'>char</span>,
    <span class='doccomment'>/// Boolean indication of whether the output should be left-aligned
</span>    <span class='kw'>pub</span> <span class='ident'>align</span>: <span class='ident'>rt</span>::<span class='ident'>Alignment</span>,
    <span class='doccomment'>/// Optionally specified integer width that the output should be
</span>    <span class='kw'>pub</span> <span class='ident'>width</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span>,
    <span class='doccomment'>/// Optionally specified precision for numeric types
</span>    <span class='kw'>pub</span> <span class='ident'>precision</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span>,

    <span class='doccomment'>/// Output buffer.
</span>    <span class='kw'>pub</span> <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>io</span>::<span class='ident'>Writer</span>,
    <span class='ident'>curarg</span>: <span class='ident'>slice</span>::<span class='ident'>Items</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>Argument</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;&gt;</span>,
    <span class='ident'>args</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> [<span class='ident'>Argument</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>],
}

<span class='doccomment'>/// This struct represents the generic &quot;argument&quot; which is taken by the Xprintf
</span><span class='doccomment'>/// family of functions. It contains a function to format the given value. At
</span><span class='doccomment'>/// compile time it is ensured that the function and the value have the correct
</span><span class='doccomment'>/// types, and then this struct is used to canonicalize arguments to one type.
</span><span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Argument</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>formatter</span>: <span class='kw'>extern</span> <span class='string'>&quot;Rust&quot;</span> <span class='kw'>fn</span>(<span class='kw-2'>&amp;</span><span class='ident'>any</span>::<span class='ident'>Void</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>,
    <span class='ident'>value</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>any</span>::<span class='ident'>Void</span>,
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='ident'>Arguments</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='doccomment'>/// When using the format_args!() macro, this function is used to generate the
</span>    <span class='doccomment'>/// Arguments structure. The compiler inserts an `unsafe` block to call this,
</span>    <span class='doccomment'>/// which is valid because the compiler performs all necessary validation to
</span>    <span class='doccomment'>/// ensure that the resulting call to format/write would be safe.
</span>    <span class='attribute'>#[<span class='ident'>doc</span>(<span class='ident'>hidden</span>)]</span> <span class='attribute'>#[<span class='ident'>inline</span>]</span>
    <span class='kw'>pub</span> <span class='kw'>unsafe</span> <span class='kw'>fn</span> <span class='ident'>new</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>fmt</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> [<span class='ident'>rt</span>::<span class='ident'>Piece</span><span class='op'>&lt;</span><span class='lifetime'>&#39;static</span><span class='op'>&gt;</span>],
                          <span class='ident'>args</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> [<span class='ident'>Argument</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>]) <span class='op'>-&gt;</span> <span class='ident'>Arguments</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
        <span class='ident'>Arguments</span>{ <span class='ident'>fmt</span>: <span class='ident'>mem</span>::<span class='ident'>transmute</span>(<span class='ident'>fmt</span>), <span class='ident'>args</span>: <span class='ident'>args</span> }
    }
}

<span class='doccomment'>/// This structure represents a safely precompiled version of a format string
</span><span class='doccomment'>/// and its arguments. This cannot be generated at runtime because it cannot
</span><span class='doccomment'>/// safely be done so, so no constructors are given and the fields are private
</span><span class='doccomment'>/// to prevent modification.
</span><span class='doccomment'>///
</span><span class='doccomment'>/// The `format_args!` macro will safely create an instance of this structure
</span><span class='doccomment'>/// and pass it to a user-supplied function. The macro validates the format
</span><span class='doccomment'>/// string at compile-time so usage of the `write` and `format` functions can
</span><span class='doccomment'>/// be safely performed.
</span><span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Arguments</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>fmt</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> [<span class='ident'>rt</span>::<span class='ident'>Piece</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>],
    <span class='ident'>args</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> [<span class='ident'>Argument</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>],
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='ident'>Arguments</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>fmt</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='ident'>write</span>(<span class='ident'>fmt</span>.<span class='ident'>buf</span>, <span class='self'>self</span>)
    }
}

<span class='doccomment'>/// When a format is not otherwise specified, types are formatted by ascribing
</span><span class='doccomment'>/// to this trait. There is not an explicit way of selecting this trait to be
</span><span class='doccomment'>/// used for formatting, it is only if no other format is specified.
</span><span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Show</span> {
    <span class='doccomment'>/// Formats the value using the given formatter.
</span>    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>;
}

<span class='doccomment'>/// Format trait for the `b` character
</span><span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Bool</span> {
    <span class='doccomment'>/// Formats the value using the given formatter.
</span>    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>;
}

<span class='doccomment'>/// Format trait for the `c` character
</span><span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Char</span> {
    <span class='doccomment'>/// Formats the value using the given formatter.
</span>    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>;
}

<span class='doccomment'>/// Format trait for the `i` and `d` characters
</span><span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Signed</span> {
    <span class='doccomment'>/// Formats the value using the given formatter.
</span>    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>;
}

<span class='doccomment'>/// Format trait for the `u` character
</span><span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Unsigned</span> {
    <span class='doccomment'>/// Formats the value using the given formatter.
</span>    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>;
}

<span class='doccomment'>/// Format trait for the `o` character
</span><span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Octal</span> {
    <span class='doccomment'>/// Formats the value using the given formatter.
</span>    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>;
}

<span class='doccomment'>/// Format trait for the `t` character
</span><span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Binary</span> {
    <span class='doccomment'>/// Formats the value using the given formatter.
</span>    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>;
}

<span class='doccomment'>/// Format trait for the `x` character
</span><span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>LowerHex</span> {
    <span class='doccomment'>/// Formats the value using the given formatter.
</span>    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>;
}

<span class='doccomment'>/// Format trait for the `X` character
</span><span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>UpperHex</span> {
    <span class='doccomment'>/// Formats the value using the given formatter.
</span>    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>;
}

<span class='doccomment'>/// Format trait for the `s` character
</span><span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>String</span> {
    <span class='doccomment'>/// Formats the value using the given formatter.
</span>    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>;
}

<span class='doccomment'>/// Format trait for the `?` character
</span><span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Poly</span> {
    <span class='doccomment'>/// Formats the value using the given formatter.
</span>    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>;
}

<span class='doccomment'>/// Format trait for the `p` character
</span><span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Pointer</span> {
    <span class='doccomment'>/// Formats the value using the given formatter.
</span>    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>;
}

<span class='doccomment'>/// Format trait for the `f` character
</span><span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>Float</span> {
    <span class='doccomment'>/// Formats the value using the given formatter.
</span>    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>;
}

<span class='doccomment'>/// Format trait for the `e` character
</span><span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>LowerExp</span> {
    <span class='doccomment'>/// Formats the value using the given formatter.
</span>    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>;
}

<span class='doccomment'>/// Format trait for the `E` character
</span><span class='kw'>pub</span> <span class='kw'>trait</span> <span class='ident'>UpperExp</span> {
    <span class='doccomment'>/// Formats the value using the given formatter.
</span>    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>;
}<span class='comment'>

// FIXME #11938 - UFCS would make us able call the above methods
// directly Show::show(x, fmt).
</span><span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>uniform_fn_call_workaround</span> {
    ($( <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>name</span>: <span class='ident'>ident</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>trait_</span>: <span class='ident'>ident</span>; )<span class='op'>*</span>) <span class='op'>=&gt;</span> {
        $(
            <span class='attribute'>#[<span class='ident'>doc</span>(<span class='ident'>hidden</span>)]</span>
            <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>name</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>trait_</span><span class='op'>&gt;</span>(<span class='ident'>x</span>: <span class='kw-2'>&amp;</span><span class='ident'>T</span>, <span class='ident'>fmt</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
                <span class='ident'>x</span>.<span class='ident'>fmt</span>(<span class='ident'>fmt</span>)
            }
            )<span class='op'>*</span>
    }
}
<span class='macro'>uniform_fn_call_workaround</span><span class='macro'>!</span> {
    <span class='ident'>secret_show</span>, <span class='ident'>Show</span>;
    <span class='ident'>secret_bool</span>, <span class='ident'>Bool</span>;
    <span class='ident'>secret_char</span>, <span class='ident'>Char</span>;
    <span class='ident'>secret_signed</span>, <span class='ident'>Signed</span>;
    <span class='ident'>secret_unsigned</span>, <span class='ident'>Unsigned</span>;
    <span class='ident'>secret_octal</span>, <span class='ident'>Octal</span>;
    <span class='ident'>secret_binary</span>, <span class='ident'>Binary</span>;
    <span class='ident'>secret_lower_hex</span>, <span class='ident'>LowerHex</span>;
    <span class='ident'>secret_upper_hex</span>, <span class='ident'>UpperHex</span>;
    <span class='ident'>secret_string</span>, <span class='ident'>String</span>;
    <span class='ident'>secret_poly</span>, <span class='ident'>Poly</span>;
    <span class='ident'>secret_pointer</span>, <span class='ident'>Pointer</span>;
    <span class='ident'>secret_float</span>, <span class='ident'>Float</span>;
    <span class='ident'>secret_lower_exp</span>, <span class='ident'>LowerExp</span>;
    <span class='ident'>secret_upper_exp</span>, <span class='ident'>UpperExp</span>;
}

<span class='doccomment'>/// The `write` function takes an output stream, a precompiled format string,
</span><span class='doccomment'>/// and a list of arguments. The arguments will be formatted according to the
</span><span class='doccomment'>/// specified format string into the output stream provided.
</span><span class='doccomment'>///
</span><span class='doccomment'>/// # Arguments
</span><span class='doccomment'>///
</span><span class='doccomment'>///   * output - the buffer to write output to
</span><span class='doccomment'>///   * args - the precompiled arguments generated by `format_args!`
</span><span class='doccomment'>///
</span><span class='doccomment'>/// # Example
</span><span class='doccomment'>///
</span><span class='doccomment'>/// ```rust
</span><span class='doccomment'>/// # #![allow(unused_must_use)]
</span><span class='doccomment'>/// use std::fmt;
</span><span class='doccomment'>/// use std::io;
</span><span class='doccomment'>///
</span><span class='doccomment'>/// let mut w = io::stdout();
</span><span class='doccomment'>/// format_args!(|args| { fmt::write(&amp;mut w, args); }, &quot;Hello, {}!&quot;, &quot;world&quot;);
</span><span class='doccomment'>/// ```
</span><span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>write</span>(<span class='ident'>output</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>io</span>::<span class='ident'>Writer</span>, <span class='ident'>args</span>: <span class='kw-2'>&amp;</span><span class='ident'>Arguments</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>write_unsafe</span>(<span class='ident'>output</span>, <span class='ident'>args</span>.<span class='ident'>fmt</span>, <span class='ident'>args</span>.<span class='ident'>args</span>) }
}

<span class='doccomment'>/// The `writeln` function takes the same arguments as `write`, except that it
</span><span class='doccomment'>/// will also write a newline (`\n`) character at the end of the format string.
</span><span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>writeln</span>(<span class='ident'>output</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>io</span>::<span class='ident'>Writer</span>, <span class='ident'>args</span>: <span class='kw-2'>&amp;</span><span class='ident'>Arguments</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
    <span class='kw'>let</span> <span class='ident'>first</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='ident'>write_unsafe</span>(<span class='ident'>output</span>, <span class='ident'>args</span>.<span class='ident'>fmt</span>, <span class='ident'>args</span>.<span class='ident'>args</span>) };
    <span class='ident'>first</span>.<span class='ident'>and_then</span>(<span class='op'>|</span>()<span class='op'>|</span> <span class='ident'>output</span>.<span class='ident'>write</span>([<span class='string'>&#39;\n&#39;</span> <span class='kw'>as</span> <span class='ident'>u8</span>]))
}

<span class='doccomment'>/// The `write_unsafe` function takes an output stream, a precompiled format
</span><span class='doccomment'>/// string, and a list of arguments. The arguments will be formatted according
</span><span class='doccomment'>/// to the specified format string into the output stream provided.
</span><span class='doccomment'>///
</span><span class='doccomment'>/// See the documentation for `format` for why this function is unsafe and care
</span><span class='doccomment'>/// should be taken if calling it manually.
</span><span class='doccomment'>///
</span><span class='doccomment'>/// Thankfully the rust compiler provides macros like `write!` and
</span><span class='doccomment'>/// `format_args!` which perform all of this validation at compile-time
</span><span class='doccomment'>/// and provide a safe interface for invoking this function.
</span><span class='doccomment'>///
</span><span class='doccomment'>/// # Arguments
</span><span class='doccomment'>///
</span><span class='doccomment'>///   * output - the buffer to write output to
</span><span class='doccomment'>///   * fmts - the precompiled format string to emit
</span><span class='doccomment'>///   * args - the list of arguments to the format string. These are only the
</span><span class='doccomment'>///            positional arguments (not named)
</span><span class='doccomment'>///
</span><span class='doccomment'>/// Note that this function assumes that there are enough arguments for the
</span><span class='doccomment'>/// format string.
</span><span class='kw'>pub</span> <span class='kw'>unsafe</span> <span class='kw'>fn</span> <span class='ident'>write_unsafe</span>(<span class='ident'>output</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>io</span>::<span class='ident'>Writer</span>,
                           <span class='ident'>fmt</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>rt</span>::<span class='ident'>Piece</span>],
                           <span class='ident'>args</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>Argument</span>]) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>formatter</span> <span class='op'>=</span> <span class='ident'>Formatter</span> {
        <span class='ident'>flags</span>: <span class='number'>0</span>,
        <span class='ident'>width</span>: <span class='prelude-val'>None</span>,
        <span class='ident'>precision</span>: <span class='prelude-val'>None</span>,
        <span class='ident'>buf</span>: <span class='ident'>output</span>,
        <span class='ident'>align</span>: <span class='ident'>rt</span>::<span class='ident'>AlignUnknown</span>,
        <span class='ident'>fill</span>: <span class='string'>&#39; &#39;</span>,
        <span class='ident'>args</span>: <span class='ident'>args</span>,
        <span class='ident'>curarg</span>: <span class='ident'>args</span>.<span class='ident'>iter</span>(),
    };
    <span class='kw'>for</span> <span class='ident'>piece</span> <span class='kw'>in</span> <span class='ident'>fmt</span>.<span class='ident'>iter</span>() {
        <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>formatter</span>.<span class='ident'>run</span>(<span class='ident'>piece</span>, <span class='prelude-val'>None</span>));
    }
    <span class='prelude-val'>Ok</span>(())
}

<span class='doccomment'>/// The format function takes a precompiled format string and a list of
</span><span class='doccomment'>/// arguments, to return the resulting formatted string.
</span><span class='doccomment'>///
</span><span class='doccomment'>/// # Arguments
</span><span class='doccomment'>///
</span><span class='doccomment'>///   * args - a structure of arguments generated via the `format_args!` macro.
</span><span class='doccomment'>///            Because this structure can only be safely generated at
</span><span class='doccomment'>///            compile-time, this function is safe.
</span><span class='doccomment'>///
</span><span class='doccomment'>/// # Example
</span><span class='doccomment'>///
</span><span class='doccomment'>/// ```rust
</span><span class='doccomment'>/// use std::fmt;
</span><span class='doccomment'>///
</span><span class='doccomment'>/// let s = format_args!(fmt::format, &quot;Hello, {}!&quot;, &quot;world&quot;);
</span><span class='doccomment'>/// assert_eq!(s, &quot;Hello, world!&quot;.to_owned());
</span><span class='doccomment'>/// ```
</span><span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>format</span>(<span class='ident'>args</span>: <span class='kw-2'>&amp;</span><span class='ident'>Arguments</span>) <span class='op'>-&gt;</span> <span class='kw-2'>~</span><span class='ident'>str</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>format_unsafe</span>(<span class='ident'>args</span>.<span class='ident'>fmt</span>, <span class='ident'>args</span>.<span class='ident'>args</span>) }
}

<span class='doccomment'>/// The unsafe version of the formatting function.
</span><span class='doccomment'>///
</span><span class='doccomment'>/// This is currently an unsafe function because the types of all arguments
</span><span class='doccomment'>/// aren&#39;t verified by immediate callers of this function. This currently does
</span><span class='doccomment'>/// not validate that the correct types of arguments are specified for each
</span><span class='doccomment'>/// format specifier, nor that each argument itself contains the right function
</span><span class='doccomment'>/// for formatting the right type value. Because of this, the function is marked
</span><span class='doccomment'>/// as `unsafe` if this is being called manually.
</span><span class='doccomment'>///
</span><span class='doccomment'>/// Thankfully the rust compiler provides the macro `format!` which will perform
</span><span class='doccomment'>/// all of this validation at compile-time and provides a safe interface for
</span><span class='doccomment'>/// invoking this function.
</span><span class='doccomment'>///
</span><span class='doccomment'>/// # Arguments
</span><span class='doccomment'>///
</span><span class='doccomment'>///   * fmts - the precompiled format string to emit.
</span><span class='doccomment'>///   * args - the list of arguments to the format string. These are only the
</span><span class='doccomment'>///            positional arguments (not named)
</span><span class='doccomment'>///
</span><span class='doccomment'>/// Note that this function assumes that there are enough arguments for the
</span><span class='doccomment'>/// format string.
</span><span class='kw'>pub</span> <span class='kw'>unsafe</span> <span class='kw'>fn</span> <span class='ident'>format_unsafe</span>(<span class='ident'>fmt</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>rt</span>::<span class='ident'>Piece</span>], <span class='ident'>args</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>Argument</span>]) <span class='op'>-&gt;</span> <span class='kw-2'>~</span><span class='ident'>str</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>output</span> <span class='op'>=</span> <span class='ident'>MemWriter</span>::<span class='ident'>new</span>();
    <span class='ident'>write_unsafe</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>output</span> <span class='kw'>as</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>io</span>::<span class='ident'>Writer</span>, <span class='ident'>fmt</span>, <span class='ident'>args</span>).<span class='ident'>unwrap</span>();
    <span class='kw'>return</span> <span class='ident'>str</span>::<span class='ident'>from_utf8</span>(<span class='ident'>output</span>.<span class='ident'>unwrap</span>().<span class='ident'>as_slice</span>()).<span class='ident'>unwrap</span>().<span class='ident'>to_owned</span>();
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='ident'>Formatter</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {<span class='comment'>

    // First up is the collection of functions used to execute a format string
    // at runtime. This consumes all of the compile-time statics generated by
    // the format! syntax extension.

    </span><span class='kw'>fn</span> <span class='ident'>run</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>piece</span>: <span class='kw-2'>&amp;</span><span class='ident'>rt</span>::<span class='ident'>Piece</span>, <span class='ident'>cur</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='ident'>piece</span> {
            <span class='ident'>rt</span>::<span class='ident'>String</span>(<span class='ident'>s</span>) <span class='op'>=&gt;</span> <span class='self'>self</span>.<span class='ident'>buf</span>.<span class='ident'>write</span>(<span class='ident'>s</span>.<span class='ident'>as_bytes</span>()),
            <span class='ident'>rt</span>::<span class='ident'>CurrentArgument</span>(()) <span class='op'>=&gt;</span> <span class='self'>self</span>.<span class='ident'>buf</span>.<span class='ident'>write</span>(<span class='ident'>cur</span>.<span class='ident'>unwrap</span>().<span class='ident'>as_bytes</span>()),
            <span class='ident'>rt</span>::<span class='ident'>Argument</span>(<span class='kw-2'>ref</span> <span class='ident'>arg</span>) <span class='op'>=&gt;</span> {<span class='comment'>
                // Fill in the format parameters into the formatter
                </span><span class='self'>self</span>.<span class='ident'>fill</span> <span class='op'>=</span> <span class='ident'>arg</span>.<span class='ident'>format</span>.<span class='ident'>fill</span>;
                <span class='self'>self</span>.<span class='ident'>align</span> <span class='op'>=</span> <span class='ident'>arg</span>.<span class='ident'>format</span>.<span class='ident'>align</span>;
                <span class='self'>self</span>.<span class='ident'>flags</span> <span class='op'>=</span> <span class='ident'>arg</span>.<span class='ident'>format</span>.<span class='ident'>flags</span>;
                <span class='self'>self</span>.<span class='ident'>width</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>getcount</span>(<span class='kw-2'>&amp;</span><span class='ident'>arg</span>.<span class='ident'>format</span>.<span class='ident'>width</span>);
                <span class='self'>self</span>.<span class='ident'>precision</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>getcount</span>(<span class='kw-2'>&amp;</span><span class='ident'>arg</span>.<span class='ident'>format</span>.<span class='ident'>precision</span>);<span class='comment'>

                // Extract the correct argument
                </span><span class='kw'>let</span> <span class='ident'>value</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>arg</span>.<span class='ident'>position</span> {
                    <span class='ident'>rt</span>::<span class='ident'>ArgumentNext</span> <span class='op'>=&gt;</span> { <span class='op'>*</span><span class='self'>self</span>.<span class='ident'>curarg</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>() }
                    <span class='ident'>rt</span>::<span class='ident'>ArgumentIs</span>(<span class='ident'>i</span>) <span class='op'>=&gt;</span> <span class='self'>self</span>.<span class='ident'>args</span>[<span class='ident'>i</span>],
                };<span class='comment'>

                // Then actually do some printing
                </span><span class='kw'>match</span> <span class='ident'>arg</span>.<span class='ident'>method</span> {
                    <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> (<span class='ident'>value</span>.<span class='ident'>formatter</span>)(<span class='ident'>value</span>.<span class='ident'>value</span>, <span class='self'>self</span>),
                    <span class='prelude-val'>Some</span>(<span class='kw-2'>ref</span> <span class='ident'>method</span>) <span class='op'>=&gt;</span> <span class='self'>self</span>.<span class='ident'>execute</span>(<span class='op'>*</span><span class='ident'>method</span>, <span class='ident'>value</span>)
                }
            }
        }
    }

    <span class='kw'>fn</span> <span class='ident'>getcount</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>cnt</span>: <span class='kw-2'>&amp;</span><span class='ident'>rt</span>::<span class='ident'>Count</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='ident'>cnt</span> {
            <span class='ident'>rt</span>::<span class='ident'>CountIs</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> { <span class='prelude-val'>Some</span>(<span class='ident'>n</span>) }
            <span class='ident'>rt</span>::<span class='ident'>CountImplied</span> <span class='op'>=&gt;</span> { <span class='prelude-val'>None</span> }
            <span class='ident'>rt</span>::<span class='ident'>CountIsParam</span>(<span class='ident'>i</span>) <span class='op'>=&gt;</span> {
                <span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>args</span>[<span class='ident'>i</span>].<span class='ident'>value</span>;
                <span class='kw'>unsafe</span> { <span class='prelude-val'>Some</span>(<span class='op'>*</span>(<span class='ident'>v</span> <span class='kw'>as</span> <span class='op'>*</span><span class='ident'>any</span>::<span class='ident'>Void</span> <span class='kw'>as</span> <span class='op'>*</span><span class='ident'>uint</span>)) }
            }
            <span class='ident'>rt</span>::<span class='ident'>CountIsNextParam</span> <span class='op'>=&gt;</span> {
                <span class='kw'>let</span> <span class='ident'>v</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>curarg</span>.<span class='ident'>next</span>().<span class='ident'>unwrap</span>().<span class='ident'>value</span>;
                <span class='kw'>unsafe</span> { <span class='prelude-val'>Some</span>(<span class='op'>*</span>(<span class='ident'>v</span> <span class='kw'>as</span> <span class='op'>*</span><span class='ident'>any</span>::<span class='ident'>Void</span> <span class='kw'>as</span> <span class='op'>*</span><span class='ident'>uint</span>)) }
            }
        }
    }

    <span class='kw'>fn</span> <span class='ident'>execute</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>method</span>: <span class='kw-2'>&amp;</span><span class='ident'>rt</span>::<span class='ident'>Method</span>, <span class='ident'>arg</span>: <span class='ident'>Argument</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='ident'>method</span> {<span class='comment'>
            // Pluralization is selection upon a numeric value specified as the
            // parameter.
            </span><span class='ident'>rt</span>::<span class='ident'>Plural</span>(<span class='ident'>offset</span>, <span class='kw-2'>ref</span> <span class='ident'>selectors</span>, <span class='kw-2'>ref</span> <span class='ident'>default</span>) <span class='op'>=&gt;</span> {<span class='comment'>
                // This is validated at compile-time to be a pointer to a
                // &#39;&amp;uint&#39; value.
                </span><span class='kw'>let</span> <span class='ident'>value</span>: <span class='kw-2'>&amp;</span><span class='ident'>uint</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='ident'>mem</span>::<span class='ident'>transmute</span>(<span class='ident'>arg</span>.<span class='ident'>value</span>) };
                <span class='kw'>let</span> <span class='ident'>value</span> <span class='op'>=</span> <span class='op'>*</span><span class='ident'>value</span>;<span class='comment'>

                // First, attempt to match against explicit values without the
                // offsetted value
                </span><span class='kw'>for</span> <span class='ident'>s</span> <span class='kw'>in</span> <span class='ident'>selectors</span>.<span class='ident'>iter</span>() {
                    <span class='kw'>match</span> <span class='ident'>s</span>.<span class='ident'>selector</span> {
                        <span class='ident'>rt</span>::<span class='ident'>Literal</span>(<span class='ident'>val</span>) <span class='kw'>if</span> <span class='ident'>value</span> <span class='op'>==</span> <span class='ident'>val</span> <span class='op'>=&gt;</span> {
                            <span class='kw'>return</span> <span class='self'>self</span>.<span class='ident'>runplural</span>(<span class='ident'>value</span>, <span class='ident'>s</span>.<span class='ident'>result</span>);
                        }
                        _ <span class='op'>=&gt;</span> {}
                    }
                }<span class='comment'>

                // Next, offset the value and attempt to match against the
                // keyword selectors.
                </span><span class='kw'>let</span> <span class='ident'>value</span> <span class='op'>=</span> <span class='ident'>value</span> <span class='op'>-</span> <span class='kw'>match</span> <span class='ident'>offset</span> { <span class='prelude-val'>Some</span>(<span class='ident'>i</span>) <span class='op'>=&gt;</span> <span class='ident'>i</span>, <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='number'>0</span> };
                <span class='kw'>for</span> <span class='ident'>s</span> <span class='kw'>in</span> <span class='ident'>selectors</span>.<span class='ident'>iter</span>() {
                    <span class='kw'>let</span> <span class='ident'>run</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>s</span>.<span class='ident'>selector</span> {
                        <span class='ident'>rt</span>::<span class='ident'>Keyword</span>(<span class='ident'>rt</span>::<span class='ident'>Zero</span>) <span class='op'>=&gt;</span> <span class='ident'>value</span> <span class='op'>==</span> <span class='number'>0</span>,
                        <span class='ident'>rt</span>::<span class='ident'>Keyword</span>(<span class='ident'>rt</span>::<span class='ident'>One</span>) <span class='op'>=&gt;</span> <span class='ident'>value</span> <span class='op'>==</span> <span class='number'>1</span>,
                        <span class='ident'>rt</span>::<span class='ident'>Keyword</span>(<span class='ident'>rt</span>::<span class='ident'>Two</span>) <span class='op'>=&gt;</span> <span class='ident'>value</span> <span class='op'>==</span> <span class='number'>2</span>,<span class='comment'>

                        // FIXME: Few/Many should have a user-specified boundary
                        //      One possible option would be in the function
                        //      pointer of the &#39;arg: Argument&#39; struct.
                        </span><span class='ident'>rt</span>::<span class='ident'>Keyword</span>(<span class='ident'>rt</span>::<span class='ident'>Few</span>) <span class='op'>=&gt;</span> <span class='ident'>value</span> <span class='op'>&lt;</span> <span class='number'>8</span>,
                        <span class='ident'>rt</span>::<span class='ident'>Keyword</span>(<span class='ident'>rt</span>::<span class='ident'>Many</span>) <span class='op'>=&gt;</span> <span class='ident'>value</span> <span class='op'>&gt;=</span> <span class='number'>8</span>,

                        <span class='ident'>rt</span>::<span class='ident'>Literal</span>(..) <span class='op'>=&gt;</span> <span class='boolval'>false</span>
                    };
                    <span class='kw'>if</span> <span class='ident'>run</span> {
                        <span class='kw'>return</span> <span class='self'>self</span>.<span class='ident'>runplural</span>(<span class='ident'>value</span>, <span class='ident'>s</span>.<span class='ident'>result</span>);
                    }
                }

                <span class='self'>self</span>.<span class='ident'>runplural</span>(<span class='ident'>value</span>, <span class='op'>*</span><span class='ident'>default</span>)
            }<span class='comment'>

            // Select is just a matching against the string specified.
            </span><span class='ident'>rt</span>::<span class='ident'>Select</span>(<span class='kw-2'>ref</span> <span class='ident'>selectors</span>, <span class='kw-2'>ref</span> <span class='ident'>default</span>) <span class='op'>=&gt;</span> {<span class='comment'>
                // This is validated at compile-time to be a pointer to a
                // string slice,
                </span><span class='kw'>let</span> <span class='ident'>value</span>: <span class='op'>&amp;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='ident'>mem</span>::<span class='ident'>transmute</span>(<span class='ident'>arg</span>.<span class='ident'>value</span>) };
                <span class='kw'>let</span> <span class='ident'>value</span> <span class='op'>=</span> <span class='op'>*</span><span class='ident'>value</span>;

                <span class='kw'>for</span> <span class='ident'>s</span> <span class='kw'>in</span> <span class='ident'>selectors</span>.<span class='ident'>iter</span>() {
                    <span class='kw'>if</span> <span class='ident'>s</span>.<span class='ident'>selector</span> <span class='op'>==</span> <span class='ident'>value</span> {
                        <span class='kw'>for</span> <span class='ident'>piece</span> <span class='kw'>in</span> <span class='ident'>s</span>.<span class='ident'>result</span>.<span class='ident'>iter</span>() {
                            <span class='macro'>try</span><span class='macro'>!</span>(<span class='self'>self</span>.<span class='ident'>run</span>(<span class='ident'>piece</span>, <span class='prelude-val'>Some</span>(<span class='ident'>value</span>)));
                        }
                        <span class='kw'>return</span> <span class='prelude-val'>Ok</span>(());
                    }
                }
                <span class='kw'>for</span> <span class='ident'>piece</span> <span class='kw'>in</span> <span class='ident'>default</span>.<span class='ident'>iter</span>() {
                    <span class='macro'>try</span><span class='macro'>!</span>(<span class='self'>self</span>.<span class='ident'>run</span>(<span class='ident'>piece</span>, <span class='prelude-val'>Some</span>(<span class='ident'>value</span>)));
                }
                <span class='prelude-val'>Ok</span>(())
            }
        }
    }

    <span class='kw'>fn</span> <span class='ident'>runplural</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>value</span>: <span class='ident'>uint</span>, <span class='ident'>pieces</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>rt</span>::<span class='ident'>Piece</span>]) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        ::<span class='ident'>uint</span>::<span class='ident'>to_str_bytes</span>(<span class='ident'>value</span>, <span class='number'>10</span>, <span class='op'>|</span><span class='ident'>buf</span><span class='op'>|</span> {
            <span class='kw'>let</span> <span class='ident'>valuestr</span> <span class='op'>=</span> <span class='ident'>str</span>::<span class='ident'>from_utf8</span>(<span class='ident'>buf</span>).<span class='ident'>unwrap</span>();
            <span class='kw'>for</span> <span class='ident'>piece</span> <span class='kw'>in</span> <span class='ident'>pieces</span>.<span class='ident'>iter</span>() {
                <span class='macro'>try</span><span class='macro'>!</span>(<span class='self'>self</span>.<span class='ident'>run</span>(<span class='ident'>piece</span>, <span class='prelude-val'>Some</span>(<span class='ident'>valuestr</span>)));
            }
            <span class='prelude-val'>Ok</span>(())
        })
    }<span class='comment'>

    // Helper methods used for padding and processing formatting arguments that
    // all formatting traits can use.

    </span><span class='doccomment'>/// Performs the correct padding for an integer which has already been
</span>    <span class='doccomment'>/// emitted into a byte-array. The byte-array should *not* contain the sign
</span>    <span class='doccomment'>/// for the integer, that will be added by this method.
</span>    <span class='doccomment'>///
</span>    <span class='doccomment'>/// # Arguments
</span>    <span class='doccomment'>///
</span>    <span class='doccomment'>/// * is_positive - whether the original integer was positive or not.
</span>    <span class='doccomment'>/// * prefix - if the &#39;#&#39; character (FlagAlternate) is provided, this
</span>    <span class='doccomment'>///   is the prefix to put in front of the number.
</span>    <span class='doccomment'>/// * buf - the byte array that the number has been formatted into
</span>    <span class='doccomment'>///
</span>    <span class='doccomment'>/// This function will correctly account for the flags provided as well as
</span>    <span class='doccomment'>/// the minimum width. It will not take precision into account.
</span>    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>pad_integral</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>is_positive</span>: <span class='ident'>bool</span>, <span class='ident'>prefix</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>buf</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>u8</span>]) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='kw'>use</span> <span class='ident'>fmt</span>::<span class='ident'>rt</span>::{<span class='ident'>FlagAlternate</span>, <span class='ident'>FlagSignPlus</span>, <span class='ident'>FlagSignAwareZeroPad</span>};

        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>width</span> <span class='op'>=</span> <span class='ident'>buf</span>.<span class='ident'>len</span>();

        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>sign</span> <span class='op'>=</span> <span class='prelude-val'>None</span>;
        <span class='kw'>if</span> <span class='op'>!</span><span class='ident'>is_positive</span> {
            <span class='ident'>sign</span> <span class='op'>=</span> <span class='prelude-val'>Some</span>(<span class='string'>&#39;-&#39;</span>); <span class='ident'>width</span> <span class='op'>+=</span> <span class='number'>1</span>;
        } <span class='kw'>else</span> <span class='kw'>if</span> <span class='self'>self</span>.<span class='ident'>flags</span> <span class='op'>&amp;</span> (<span class='number'>1</span> <span class='op'>&lt;&lt;</span> (<span class='ident'>FlagSignPlus</span> <span class='kw'>as</span> <span class='ident'>uint</span>)) <span class='op'>!=</span> <span class='number'>0</span> {
            <span class='ident'>sign</span> <span class='op'>=</span> <span class='prelude-val'>Some</span>(<span class='string'>&#39;+&#39;</span>); <span class='ident'>width</span> <span class='op'>+=</span> <span class='number'>1</span>;
        }

        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>prefixed</span> <span class='op'>=</span> <span class='boolval'>false</span>;
        <span class='kw'>if</span> <span class='self'>self</span>.<span class='ident'>flags</span> <span class='op'>&amp;</span> (<span class='number'>1</span> <span class='op'>&lt;&lt;</span> (<span class='ident'>FlagAlternate</span> <span class='kw'>as</span> <span class='ident'>uint</span>)) <span class='op'>!=</span> <span class='number'>0</span> {
            <span class='ident'>prefixed</span> <span class='op'>=</span> <span class='boolval'>true</span>; <span class='ident'>width</span> <span class='op'>+=</span> <span class='ident'>prefix</span>.<span class='ident'>len</span>();
        }<span class='comment'>

        // Writes the sign if it exists, and then the prefix if it was requested
        </span><span class='kw'>let</span> <span class='ident'>write_prefix</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span><span class='op'>|</span> {
            <span class='kw'>for</span> <span class='ident'>c</span> <span class='kw'>in</span> <span class='ident'>sign</span>.<span class='ident'>move_iter</span>() { <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>.<span class='ident'>write_char</span>(<span class='ident'>c</span>)); }
            <span class='kw'>if</span> <span class='ident'>prefixed</span> { <span class='ident'>f</span>.<span class='ident'>buf</span>.<span class='ident'>write_str</span>(<span class='ident'>prefix</span>) }
            <span class='kw'>else</span> { <span class='prelude-val'>Ok</span>(()) }
        };<span class='comment'>

        // The `width` field is more of a `min-width` parameter at this point.
        </span><span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>width</span> {<span class='comment'>
            // If there&#39;s no minimum length requirements then we can just
            // write the bytes.
            </span><span class='prelude-val'>None</span> <span class='op'>=&gt;</span> {
                <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>write_prefix</span>(<span class='self'>self</span>)); <span class='self'>self</span>.<span class='ident'>buf</span>.<span class='ident'>write</span>(<span class='ident'>buf</span>)
            }<span class='comment'>
            // Check if we&#39;re over the minimum width, if so then we can also
            // just write the bytes.
            </span><span class='prelude-val'>Some</span>(<span class='ident'>min</span>) <span class='kw'>if</span> <span class='ident'>width</span> <span class='op'>&gt;=</span> <span class='ident'>min</span> <span class='op'>=&gt;</span> {
                <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>write_prefix</span>(<span class='self'>self</span>)); <span class='self'>self</span>.<span class='ident'>buf</span>.<span class='ident'>write</span>(<span class='ident'>buf</span>)
            }<span class='comment'>
            // The sign and prefix goes before the padding if the fill character
            // is zero
            </span><span class='prelude-val'>Some</span>(<span class='ident'>min</span>) <span class='kw'>if</span> <span class='self'>self</span>.<span class='ident'>flags</span> <span class='op'>&amp;</span> (<span class='number'>1</span> <span class='op'>&lt;&lt;</span> (<span class='ident'>FlagSignAwareZeroPad</span> <span class='kw'>as</span> <span class='ident'>uint</span>)) <span class='op'>!=</span> <span class='number'>0</span> <span class='op'>=&gt;</span> {
                <span class='self'>self</span>.<span class='ident'>fill</span> <span class='op'>=</span> <span class='string'>&#39;0&#39;</span>;
                <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>write_prefix</span>(<span class='self'>self</span>));
                <span class='self'>self</span>.<span class='ident'>with_padding</span>(<span class='ident'>min</span> <span class='op'>-</span> <span class='ident'>width</span>, <span class='ident'>rt</span>::<span class='ident'>AlignRight</span>, <span class='op'>|</span><span class='ident'>f</span><span class='op'>|</span> <span class='ident'>f</span>.<span class='ident'>buf</span>.<span class='ident'>write</span>(<span class='ident'>buf</span>))
            }<span class='comment'>
            // Otherwise, the sign and prefix goes after the padding
            </span><span class='prelude-val'>Some</span>(<span class='ident'>min</span>) <span class='op'>=&gt;</span> {
                <span class='self'>self</span>.<span class='ident'>with_padding</span>(<span class='ident'>min</span> <span class='op'>-</span> <span class='ident'>width</span>, <span class='ident'>rt</span>::<span class='ident'>AlignRight</span>, <span class='op'>|</span><span class='ident'>f</span><span class='op'>|</span> {
                    <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>write_prefix</span>(<span class='ident'>f</span>)); <span class='ident'>f</span>.<span class='ident'>buf</span>.<span class='ident'>write</span>(<span class='ident'>buf</span>)
                })
            }
        }
    }

    <span class='doccomment'>/// This function takes a string slice and emits it to the internal buffer
</span>    <span class='doccomment'>/// after applying the relevant formatting flags specified. The flags
</span>    <span class='doccomment'>/// recognized for generic strings are:
</span>    <span class='doccomment'>///
</span>    <span class='doccomment'>/// * width - the minimum width of what to emit
</span>    <span class='doccomment'>/// * fill/align - what to emit and where to emit it if the string
</span>    <span class='doccomment'>///                provided needs to be padded
</span>    <span class='doccomment'>/// * precision - the maximum length to emit, the string is truncated if it
</span>    <span class='doccomment'>///               is longer than this length
</span>    <span class='doccomment'>///
</span>    <span class='doccomment'>/// Notably this function ignored the `flag` parameters
</span>    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>pad</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {<span class='comment'>
        // Make sure there&#39;s a fast path up front
        </span><span class='kw'>if</span> <span class='self'>self</span>.<span class='ident'>width</span>.<span class='ident'>is_none</span>() <span class='op'>&amp;&amp;</span> <span class='self'>self</span>.<span class='ident'>precision</span>.<span class='ident'>is_none</span>() {
            <span class='kw'>return</span> <span class='self'>self</span>.<span class='ident'>buf</span>.<span class='ident'>write</span>(<span class='ident'>s</span>.<span class='ident'>as_bytes</span>());
        }<span class='comment'>
        // The `precision` field can be interpreted as a `max-width` for the
        // string being formatted
        </span><span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>precision</span> {
            <span class='prelude-val'>Some</span>(<span class='ident'>max</span>) <span class='op'>=&gt;</span> {<span class='comment'>
                // If there&#39;s a maximum width and our string is longer than
                // that, then we must always have truncation. This is the only
                // case where the maximum length will matter.
                </span><span class='kw'>let</span> <span class='ident'>char_len</span> <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>char_len</span>();
                <span class='kw'>if</span> <span class='ident'>char_len</span> <span class='op'>&gt;=</span> <span class='ident'>max</span> {
                    <span class='kw'>let</span> <span class='ident'>nchars</span> <span class='op'>=</span> ::<span class='ident'>cmp</span>::<span class='ident'>min</span>(<span class='ident'>max</span>, <span class='ident'>char_len</span>);
                    <span class='kw'>return</span> <span class='self'>self</span>.<span class='ident'>buf</span>.<span class='ident'>write</span>(<span class='ident'>s</span>.<span class='ident'>slice_chars</span>(<span class='number'>0</span>, <span class='ident'>nchars</span>).<span class='ident'>as_bytes</span>());
                }
            }
            <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> {}
        }<span class='comment'>
        // The `width` field is more of a `min-width` parameter at this point.
        </span><span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>width</span> {<span class='comment'>
            // If we&#39;re under the maximum length, and there&#39;s no minimum length
            // requirements, then we can just emit the string
            </span><span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='self'>self</span>.<span class='ident'>buf</span>.<span class='ident'>write</span>(<span class='ident'>s</span>.<span class='ident'>as_bytes</span>()),<span class='comment'>
            // If we&#39;re under the maximum width, check if we&#39;re over the minimum
            // width, if so it&#39;s as easy as just emitting the string.
            </span><span class='prelude-val'>Some</span>(<span class='ident'>width</span>) <span class='kw'>if</span> <span class='ident'>s</span>.<span class='ident'>char_len</span>() <span class='op'>&gt;=</span> <span class='ident'>width</span> <span class='op'>=&gt;</span> {
                <span class='self'>self</span>.<span class='ident'>buf</span>.<span class='ident'>write</span>(<span class='ident'>s</span>.<span class='ident'>as_bytes</span>())
            }<span class='comment'>
            // If we&#39;re under both the maximum and the minimum width, then fill
            // up the minimum width with the specified string + some alignment.
            </span><span class='prelude-val'>Some</span>(<span class='ident'>width</span>) <span class='op'>=&gt;</span> {
                <span class='self'>self</span>.<span class='ident'>with_padding</span>(<span class='ident'>width</span> <span class='op'>-</span> <span class='ident'>s</span>.<span class='ident'>len</span>(), <span class='ident'>rt</span>::<span class='ident'>AlignLeft</span>, <span class='op'>|</span><span class='ident'>me</span><span class='op'>|</span> {
                    <span class='ident'>me</span>.<span class='ident'>buf</span>.<span class='ident'>write</span>(<span class='ident'>s</span>.<span class='ident'>as_bytes</span>())
                })
            }
        }
    }

    <span class='doccomment'>/// Runs a callback, emitting the correct padding either before or
</span>    <span class='doccomment'>/// afterwards depending on whether right or left alingment is requested.
</span>    <span class='kw'>fn</span> <span class='ident'>with_padding</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>,
                    <span class='ident'>padding</span>: <span class='ident'>uint</span>,
                    <span class='ident'>default</span>: <span class='ident'>rt</span>::<span class='ident'>Alignment</span>,
                    <span class='ident'>f</span>: <span class='op'>|</span><span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span><span class='op'>|</span> <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='kw'>let</span> <span class='ident'>align</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='self'>self</span>.<span class='ident'>align</span> {
            <span class='ident'>rt</span>::<span class='ident'>AlignUnknown</span> <span class='op'>=&gt;</span> <span class='ident'>default</span>,
            <span class='ident'>rt</span>::<span class='ident'>AlignLeft</span> <span class='op'>|</span> <span class='ident'>rt</span>::<span class='ident'>AlignRight</span> <span class='op'>=&gt;</span> <span class='self'>self</span>.<span class='ident'>align</span>
        };
        <span class='kw'>if</span> <span class='ident'>align</span> <span class='op'>==</span> <span class='ident'>rt</span>::<span class='ident'>AlignLeft</span> {
            <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>f</span>(<span class='self'>self</span>));
        }
        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>fill</span> <span class='op'>=</span> [<span class='number'>0u8</span>, ..<span class='number'>4</span>];
        <span class='kw'>let</span> <span class='ident'>len</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>fill</span>.<span class='ident'>encode_utf8</span>(<span class='ident'>fill</span>);
        <span class='kw'>for</span> _ <span class='kw'>in</span> <span class='ident'>range</span>(<span class='number'>0</span>, <span class='ident'>padding</span>) {
            <span class='macro'>try</span><span class='macro'>!</span>(<span class='self'>self</span>.<span class='ident'>buf</span>.<span class='ident'>write</span>(<span class='ident'>fill</span>.<span class='ident'>slice_to</span>(<span class='ident'>len</span>)));
        }
        <span class='kw'>if</span> <span class='ident'>align</span> <span class='op'>==</span> <span class='ident'>rt</span>::<span class='ident'>AlignRight</span> {
            <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>f</span>(<span class='self'>self</span>));
        }
        <span class='prelude-val'>Ok</span>(())
    }
}

<span class='doccomment'>/// This is a function which calls are emitted to by the compiler itself to
</span><span class='doccomment'>/// create the Argument structures that are passed into the `format` function.
</span><span class='attribute'>#[<span class='ident'>doc</span>(<span class='ident'>hidden</span>)]</span> <span class='attribute'>#[<span class='ident'>inline</span>]</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>argument</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>f</span>: <span class='kw'>extern</span> <span class='string'>&quot;Rust&quot;</span> <span class='kw'>fn</span>(<span class='kw-2'>&amp;</span><span class='ident'>T</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span>,
                       <span class='ident'>t</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>Argument</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='kw'>unsafe</span> {
        <span class='ident'>Argument</span> {
            <span class='ident'>formatter</span>: <span class='ident'>mem</span>::<span class='ident'>transmute</span>(<span class='ident'>f</span>),
            <span class='ident'>value</span>: <span class='ident'>mem</span>::<span class='ident'>transmute</span>(<span class='ident'>t</span>)
        }
    }
}

<span class='doccomment'>/// When the compiler determines that the type of an argument *must* be a string
</span><span class='doccomment'>/// (such as for select), then it invokes this method.
</span><span class='attribute'>#[<span class='ident'>doc</span>(<span class='ident'>hidden</span>)]</span> <span class='attribute'>#[<span class='ident'>inline</span>]</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>argumentstr</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>Argument</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>argument</span>(<span class='ident'>secret_string</span>, <span class='ident'>s</span>)
}

<span class='doccomment'>/// When the compiler determines that the type of an argument *must* be a uint
</span><span class='doccomment'>/// (such as for plural), then it invokes this method.
</span><span class='attribute'>#[<span class='ident'>doc</span>(<span class='ident'>hidden</span>)]</span> <span class='attribute'>#[<span class='ident'>inline</span>]</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>argumentuint</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>uint</span>) <span class='op'>-&gt;</span> <span class='ident'>Argument</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> {
    <span class='ident'>argument</span>(<span class='ident'>secret_unsigned</span>, <span class='ident'>s</span>)
}<span class='comment'>

// Implementations of the core formatting traits

</span><span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Show</span><span class='op'>&gt;</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='kw-2'>@</span><span class='ident'>T</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> { <span class='ident'>secret_show</span>(<span class='kw-2'>&amp;</span><span class='op'>*</span><span class='op'>*</span><span class='self'>self</span>, <span class='ident'>f</span>) }
}
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Show</span><span class='op'>&gt;</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> { <span class='ident'>secret_show</span>(<span class='kw-2'>&amp;</span><span class='op'>*</span><span class='op'>*</span><span class='self'>self</span>, <span class='ident'>f</span>) }
}
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='ident'>Show</span><span class='op'>&gt;</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>T</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> { <span class='ident'>secret_show</span>(<span class='op'>*</span><span class='self'>self</span>, <span class='ident'>f</span>) }
}

<span class='kw'>impl</span> <span class='ident'>Bool</span> <span class='kw'>for</span> <span class='ident'>bool</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='ident'>secret_string</span>(<span class='kw-2'>&amp;</span>(<span class='kw'>if</span> <span class='op'>*</span><span class='self'>self</span> {<span class='string'>&quot;true&quot;</span>} <span class='kw'>else</span> {<span class='string'>&quot;false&quot;</span>}), <span class='ident'>f</span>)
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='ident'>str</span>::<span class='ident'>Str</span><span class='op'>&gt;</span> <span class='ident'>String</span> <span class='kw'>for</span> <span class='ident'>T</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='ident'>f</span>.<span class='ident'>pad</span>(<span class='self'>self</span>.<span class='ident'>as_slice</span>())
    }
}

<span class='kw'>impl</span> <span class='ident'>Char</span> <span class='kw'>for</span> <span class='ident'>char</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>utf8</span> <span class='op'>=</span> [<span class='number'>0u8</span>, ..<span class='number'>4</span>];
        <span class='kw'>let</span> <span class='ident'>amt</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>encode_utf8</span>(<span class='ident'>utf8</span>);
        <span class='kw'>let</span> <span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='ident'>mem</span>::<span class='ident'>transmute</span>(<span class='ident'>utf8</span>.<span class='ident'>slice_to</span>(<span class='ident'>amt</span>)) };
        <span class='ident'>secret_string</span>(<span class='kw-2'>&amp;</span><span class='ident'>s</span>, <span class='ident'>f</span>)
    }
}

<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>floating</span>((<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ty</span>:<span class='ident'>ident</span>) <span class='op'>=&gt;</span> {
    <span class='kw'>impl</span> <span class='ident'>Float</span> <span class='kw'>for</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ty</span> {
        <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>fmt</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {<span class='comment'>
            // FIXME: this shouldn&#39;t perform an allocation
            </span><span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>fmt</span>.<span class='ident'>precision</span> {
                <span class='prelude-val'>Some</span>(<span class='ident'>i</span>) <span class='op'>=&gt;</span> ::<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ty</span>::<span class='ident'>to_str_exact</span>(<span class='self'>self</span>.<span class='ident'>abs</span>(), <span class='ident'>i</span>),
                <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> ::<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ty</span>::<span class='ident'>to_str_digits</span>(<span class='self'>self</span>.<span class='ident'>abs</span>(), <span class='number'>6</span>)
            };
            <span class='ident'>fmt</span>.<span class='ident'>pad_integral</span>(<span class='op'>*</span><span class='self'>self</span> <span class='op'>&gt;=</span> <span class='number'>0.0</span>, <span class='string'>&quot;&quot;</span>, <span class='ident'>s</span>.<span class='ident'>as_bytes</span>())
        }
    }

    <span class='kw'>impl</span> <span class='ident'>LowerExp</span> <span class='kw'>for</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ty</span> {
        <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>fmt</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {<span class='comment'>
            // FIXME: this shouldn&#39;t perform an allocation
            </span><span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>fmt</span>.<span class='ident'>precision</span> {
                <span class='prelude-val'>Some</span>(<span class='ident'>i</span>) <span class='op'>=&gt;</span> ::<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ty</span>::<span class='ident'>to_str_exp_exact</span>(<span class='self'>self</span>.<span class='ident'>abs</span>(), <span class='ident'>i</span>, <span class='boolval'>false</span>),
                <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> ::<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ty</span>::<span class='ident'>to_str_exp_digits</span>(<span class='self'>self</span>.<span class='ident'>abs</span>(), <span class='number'>6</span>, <span class='boolval'>false</span>)
            };
            <span class='ident'>fmt</span>.<span class='ident'>pad_integral</span>(<span class='op'>*</span><span class='self'>self</span> <span class='op'>&gt;=</span> <span class='number'>0.0</span>, <span class='string'>&quot;&quot;</span>, <span class='ident'>s</span>.<span class='ident'>as_bytes</span>())
        }
    }

    <span class='kw'>impl</span> <span class='ident'>UpperExp</span> <span class='kw'>for</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ty</span> {
        <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>fmt</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {<span class='comment'>
            // FIXME: this shouldn&#39;t perform an allocation
            </span><span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>fmt</span>.<span class='ident'>precision</span> {
                <span class='prelude-val'>Some</span>(<span class='ident'>i</span>) <span class='op'>=&gt;</span> ::<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ty</span>::<span class='ident'>to_str_exp_exact</span>(<span class='self'>self</span>.<span class='ident'>abs</span>(), <span class='ident'>i</span>, <span class='boolval'>true</span>),
                <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> ::<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ty</span>::<span class='ident'>to_str_exp_digits</span>(<span class='self'>self</span>.<span class='ident'>abs</span>(), <span class='number'>6</span>, <span class='boolval'>true</span>)
            };
            <span class='ident'>fmt</span>.<span class='ident'>pad_integral</span>(<span class='op'>*</span><span class='self'>self</span> <span class='op'>&gt;=</span> <span class='number'>0.0</span>, <span class='string'>&quot;&quot;</span>, <span class='ident'>s</span>.<span class='ident'>as_bytes</span>())
        }
    }
})
<span class='macro'>floating</span><span class='macro'>!</span>(<span class='ident'>f32</span>)
<span class='macro'>floating</span><span class='macro'>!</span>(<span class='ident'>f64</span>)

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Poly</span> <span class='kw'>for</span> <span class='ident'>T</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='kw'>match</span> (<span class='ident'>f</span>.<span class='ident'>width</span>, <span class='ident'>f</span>.<span class='ident'>precision</span>) {
            (<span class='prelude-val'>None</span>, <span class='prelude-val'>None</span>) <span class='op'>=&gt;</span> {
                <span class='ident'>repr</span>::<span class='ident'>write_repr</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='self'>self</span>)
            }<span class='comment'>

            // If we have a specified width for formatting, then we have to make
            // this allocation of a new string
            </span>_ <span class='op'>=&gt;</span> {
                <span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>repr</span>::<span class='ident'>repr_to_str</span>(<span class='self'>self</span>);
                <span class='ident'>f</span>.<span class='ident'>pad</span>(<span class='ident'>s</span>)
            }
        }
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Pointer</span> <span class='kw'>for</span> <span class='op'>*</span><span class='ident'>T</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='ident'>f</span>.<span class='ident'>flags</span> <span class='op'>|=</span> <span class='number'>1</span> <span class='op'>&lt;&lt;</span> (<span class='ident'>rt</span>::<span class='ident'>FlagAlternate</span> <span class='kw'>as</span> <span class='ident'>uint</span>);
        <span class='ident'>secret_lower_hex</span>::<span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span>(<span class='op'>*</span><span class='self'>self</span> <span class='kw'>as</span> <span class='ident'>uint</span>), <span class='ident'>f</span>)
    }
}
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Pointer</span> <span class='kw'>for</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>T</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='ident'>secret_pointer</span>::<span class='op'>&lt;</span><span class='op'>*</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span>(<span class='op'>*</span><span class='self'>self</span> <span class='kw'>as</span> <span class='op'>*</span><span class='ident'>T</span>), <span class='ident'>f</span>)
    }
}
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Pointer</span> <span class='kw'>for</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>T</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='ident'>secret_pointer</span>::<span class='op'>&lt;</span><span class='op'>*</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span>(<span class='kw-2'>&amp;</span><span class='op'>*</span><span class='op'>*</span><span class='self'>self</span> <span class='kw'>as</span> <span class='op'>*</span><span class='ident'>T</span>), <span class='ident'>f</span>)
    }
}
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Pointer</span> <span class='kw'>for</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> <span class='ident'>T</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='ident'>secret_pointer</span>::<span class='op'>&lt;</span><span class='op'>*</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span>(<span class='kw-2'>&amp;</span><span class='op'>*</span><span class='op'>*</span><span class='self'>self</span> <span class='kw'>as</span> <span class='op'>*</span><span class='ident'>T</span>), <span class='ident'>f</span>)
    }
}<span class='comment'>

// Implementation of Show for various core types

</span><span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>delegate</span>((<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ty</span>:<span class='ident'>ty</span> <span class='ident'>to</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>other</span>:<span class='ident'>ident</span>) <span class='op'>=&gt;</span> {
    <span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>ty</span> {
        <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
            (<span class='macro'>concat_idents</span><span class='macro'>!</span>(<span class='ident'>secret_</span>, <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>other</span>)(<span class='self'>self</span>, <span class='ident'>f</span>))
        }
    }
})
<span class='macro'>delegate</span><span class='macro'>!</span>(<span class='kw-2'>~</span><span class='ident'>str</span> <span class='ident'>to</span> <span class='ident'>string</span>)
<span class='macro'>delegate</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>str</span> <span class='ident'>to</span> <span class='ident'>string</span>)
<span class='macro'>delegate</span><span class='macro'>!</span>(<span class='ident'>bool</span> <span class='ident'>to</span> <span class='ident'>bool</span>)
<span class='macro'>delegate</span><span class='macro'>!</span>(<span class='ident'>char</span> <span class='ident'>to</span> <span class='ident'>char</span>)
<span class='macro'>delegate</span><span class='macro'>!</span>(<span class='ident'>f32</span> <span class='ident'>to</span> <span class='ident'>float</span>)
<span class='macro'>delegate</span><span class='macro'>!</span>(<span class='ident'>f64</span> <span class='ident'>to</span> <span class='ident'>float</span>)

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='op'>*</span><span class='ident'>T</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> { <span class='ident'>secret_pointer</span>(<span class='self'>self</span>, <span class='ident'>f</span>) }
}
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>T</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> { <span class='ident'>secret_pointer</span>(<span class='self'>self</span>, <span class='ident'>f</span>) }
}

<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>peel</span>((<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>name</span>:<span class='ident'>ident</span>, $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>other</span>:<span class='ident'>ident</span>,)<span class='op'>*</span>) <span class='op'>=&gt;</span> (<span class='macro'>tuple</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>other</span>,)<span class='op'>*</span>)))

<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>tuple</span> (
    () <span class='op'>=&gt;</span> ();
    ( $(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>name</span>:<span class='ident'>ident</span>,)<span class='op'>+</span> ) <span class='op'>=&gt;</span> (
        <span class='kw'>impl</span><span class='op'>&lt;</span>$(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>name</span>:<span class='ident'>Show</span>),<span class='op'>*</span><span class='op'>&gt;</span> <span class='ident'>Show</span> <span class='kw'>for</span> ($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>name</span>,)<span class='op'>*</span>) {
            <span class='attribute'>#[<span class='ident'>allow</span>(<span class='ident'>uppercase_variables</span>, <span class='ident'>dead_assignment</span>)]</span>
            <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
                <span class='macro'>try</span><span class='macro'>!</span>(<span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;(&quot;</span>));
                <span class='kw'>let</span> ($(<span class='kw-2'>ref</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>name</span>,)<span class='op'>*</span>) <span class='op'>=</span> <span class='op'>*</span><span class='self'>self</span>;
                <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>n</span> <span class='op'>=</span> <span class='number'>0</span>;
                $(
                    <span class='kw'>if</span> <span class='ident'>n</span> <span class='op'>&gt;</span> <span class='number'>0</span> {
                        <span class='macro'>try</span><span class='macro'>!</span>(<span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;, &quot;</span>));
                    }
                    <span class='macro'>try</span><span class='macro'>!</span>(<span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;{}&quot;</span>, <span class='op'>*</span><span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>name</span>));
                    <span class='ident'>n</span> <span class='op'>+=</span> <span class='number'>1</span>;
                )<span class='op'>*</span>
                <span class='kw'>if</span> <span class='ident'>n</span> <span class='op'>==</span> <span class='number'>1</span> {
                    <span class='macro'>try</span><span class='macro'>!</span>(<span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;,&quot;</span>));
                }
                <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;)&quot;</span>)
            }
        }
        <span class='macro'>peel</span><span class='macro'>!</span>($(<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>name</span>,)<span class='op'>*</span>)
    )
)

<span class='macro'>tuple</span><span class='macro'>!</span> { <span class='ident'>T0</span>, <span class='ident'>T1</span>, <span class='ident'>T2</span>, <span class='ident'>T3</span>, <span class='ident'>T4</span>, <span class='ident'>T5</span>, <span class='ident'>T6</span>, <span class='ident'>T7</span>, <span class='ident'>T8</span>, <span class='ident'>T9</span>, <span class='ident'>T10</span>, <span class='ident'>T11</span>, }

<span class='kw'>impl</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>any</span>::<span class='ident'>Any</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> { <span class='ident'>f</span>.<span class='ident'>pad</span>(<span class='string'>&quot;Box&lt;Any&gt;&quot;</span>) }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='ident'>any</span>::<span class='ident'>Any</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> { <span class='ident'>f</span>.<span class='ident'>pad</span>(<span class='string'>&quot;&amp;Any&quot;</span>) }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Show</span><span class='op'>&gt;</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='prelude-val'>Some</span>(<span class='kw-2'>ref</span> <span class='ident'>t</span>) <span class='op'>=&gt;</span> <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;Some({})&quot;</span>, <span class='op'>*</span><span class='ident'>t</span>),
            <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;None&quot;</span>),
        }
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Show</span>, <span class='ident'>U</span>: <span class='ident'>Show</span><span class='op'>&gt;</span> <span class='ident'>Show</span> <span class='kw'>for</span> ::<span class='ident'>result</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>U</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='prelude-val'>Ok</span>(<span class='kw-2'>ref</span> <span class='ident'>t</span>) <span class='op'>=&gt;</span> <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;Ok({})&quot;</span>, <span class='op'>*</span><span class='ident'>t</span>),
            <span class='prelude-val'>Err</span>(<span class='kw-2'>ref</span> <span class='ident'>t</span>) <span class='op'>=&gt;</span> <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;Err({})&quot;</span>, <span class='op'>*</span><span class='ident'>t</span>),
        }
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='ident'>Show</span><span class='op'>&gt;</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> [<span class='ident'>T</span>] {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='kw'>if</span> <span class='ident'>f</span>.<span class='ident'>flags</span> <span class='op'>&amp;</span> (<span class='number'>1</span> <span class='op'>&lt;&lt;</span> (<span class='ident'>rt</span>::<span class='ident'>FlagAlternate</span> <span class='kw'>as</span> <span class='ident'>uint</span>)) <span class='op'>==</span> <span class='number'>0</span> {
            <span class='macro'>try</span><span class='macro'>!</span>(<span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;[&quot;</span>));
        }
        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>is_first</span> <span class='op'>=</span> <span class='boolval'>true</span>;
        <span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> <span class='self'>self</span>.<span class='ident'>iter</span>() {
            <span class='kw'>if</span> <span class='ident'>is_first</span> {
                <span class='ident'>is_first</span> <span class='op'>=</span> <span class='boolval'>false</span>;
            } <span class='kw'>else</span> {
                <span class='macro'>try</span><span class='macro'>!</span>(<span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;, &quot;</span>));
            }
            <span class='macro'>try</span><span class='macro'>!</span>(<span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;{}&quot;</span>, <span class='op'>*</span><span class='ident'>x</span>))
        }
        <span class='kw'>if</span> <span class='ident'>f</span>.<span class='ident'>flags</span> <span class='op'>&amp;</span> (<span class='number'>1</span> <span class='op'>&lt;&lt;</span> (<span class='ident'>rt</span>::<span class='ident'>FlagAlternate</span> <span class='kw'>as</span> <span class='ident'>uint</span>)) <span class='op'>==</span> <span class='number'>0</span> {
            <span class='macro'>try</span><span class='macro'>!</span>(<span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;]&quot;</span>));
        }
        <span class='prelude-val'>Ok</span>(())
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>T</span>: <span class='ident'>Show</span><span class='op'>&gt;</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;a</span> <span class='kw-2'>mut</span> [<span class='ident'>T</span>] {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='ident'>secret_show</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>as_slice</span>(), <span class='ident'>f</span>)
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Show</span><span class='op'>&gt;</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='kw-2'>~</span>[<span class='ident'>T</span>] {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='ident'>secret_show</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>.<span class='ident'>as_slice</span>(), <span class='ident'>f</span>)
    }
}

<span class='kw'>impl</span> <span class='ident'>Show</span> <span class='kw'>for</span> () {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='ident'>f</span>.<span class='ident'>pad</span>(<span class='string'>&quot;()&quot;</span>)
    }
}

<span class='kw'>impl</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='ident'>TypeId</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;TypeId \\{ {} \\}&quot;</span>, <span class='self'>self</span>.<span class='ident'>hash</span>())
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Show</span><span class='op'>&gt;</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='ident'>iter</span>::<span class='ident'>MinMaxResult</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='ident'>iter</span>::<span class='ident'>NoElements</span> <span class='op'>=&gt;</span>
                <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;NoElements&quot;</span>),
            <span class='ident'>iter</span>::<span class='ident'>OneElement</span>(<span class='kw-2'>ref</span> <span class='ident'>t</span>) <span class='op'>=&gt;</span>
                <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;OneElement({})&quot;</span>, <span class='op'>*</span><span class='ident'>t</span>),
            <span class='ident'>iter</span>::<span class='ident'>MinMax</span>(<span class='kw-2'>ref</span> <span class='ident'>t1</span>, <span class='kw-2'>ref</span> <span class='ident'>t2</span>) <span class='op'>=&gt;</span>
                <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;MinMax({}, {})&quot;</span>, <span class='op'>*</span><span class='ident'>t1</span>, <span class='op'>*</span><span class='ident'>t2</span>),
        }
    }
}

<span class='kw'>impl</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='ident'>cmp</span>::<span class='ident'>Ordering</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='ident'>cmp</span>::<span class='ident'>Less</span> <span class='op'>=&gt;</span> <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;Less&quot;</span>),
            <span class='ident'>cmp</span>::<span class='ident'>Greater</span> <span class='op'>=&gt;</span> <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;Greater&quot;</span>),
            <span class='ident'>cmp</span>::<span class='ident'>Equal</span> <span class='op'>=&gt;</span> <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;Equal&quot;</span>),
        }
    }
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Copy</span> <span class='op'>+</span> <span class='ident'>Show</span><span class='op'>&gt;</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='ident'>Cell</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>r&quot;Cell \{ value: {} \}&quot;</span>, <span class='self'>self</span>.<span class='ident'>get</span>())
    }
}

<span class='kw'>impl</span> <span class='ident'>Show</span> <span class='kw'>for</span> <span class='ident'>UTF16Item</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='ident'>ScalarValue</span>(<span class='ident'>c</span>) <span class='op'>=&gt;</span> <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;ScalarValue({})&quot;</span>, <span class='ident'>c</span>),
            <span class='ident'>LoneSurrogate</span>(<span class='ident'>u</span>) <span class='op'>=&gt;</span> <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;LoneSurrogate({})&quot;</span>, <span class='ident'>u</span>),
        }
    }
}<span class='comment'>

// If you expected tests to be here, look instead at the run-pass/ifmt.rs test,
// it&#39;s a lot easier than creating all of the rt::Piece structures here.
</span></pre>
</section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    <script>
        var rootPath = "../../../../../";
        var currentCrate = "std";
    </script>
    <script src="../../../../../jquery.js"></script>
    <script src="../../../../../main.js"></script>
    <script async src="../../../../../search-index.js"></script>
</body>
</html>