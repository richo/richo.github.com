<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The core library documentation.">

    <title>core::ptr - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,600'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico">
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        
            <a href='../../core/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        

        <p class='location'><a href='../index.html'>core</a></p><div class='block mod'><h2>Modules</h2><a class='mod ' href='../any/index.html'>any</a><br/><a class='mod ' href='../bool/index.html'>bool</a><br/><a class='mod ' href='../cell/index.html'>cell</a><br/><a class='mod ' href='../char/index.html'>char</a><br/><a class='mod ' href='../clone/index.html'>clone</a><br/><a class='mod ' href='../cmp/index.html'>cmp</a><br/><a class='mod ' href='../container/index.html'>container</a><br/><a class='mod ' href='../default/index.html'>default</a><br/><a class='mod ' href='../f32/index.html'>f32</a><br/><a class='mod ' href='../f64/index.html'>f64</a><br/><a class='mod ' href='../finally/index.html'>finally</a><br/><a class='mod ' href='../i16/index.html'>i16</a><br/><a class='mod ' href='../i32/index.html'>i32</a><br/><a class='mod ' href='../i64/index.html'>i64</a><br/><a class='mod ' href='../i8/index.html'>i8</a><br/><a class='mod ' href='../int/index.html'>int</a><br/><a class='mod ' href='../intrinsics/index.html'>intrinsics</a><br/><a class='mod ' href='../iter/index.html'>iter</a><br/><a class='mod ' href='../kinds/index.html'>kinds</a><br/><a class='mod ' href='../mem/index.html'>mem</a><br/><a class='mod ' href='../num/index.html'>num</a><br/><a class='mod ' href='../ops/index.html'>ops</a><br/><a class='mod ' href='../option/index.html'>option</a><br/><a class='mod ' href='../owned/index.html'>owned</a><br/><a class='mod ' href='../prelude/index.html'>prelude</a><br/><a class='mod current' href='../ptr/index.html'>ptr</a><br/><a class='mod ' href='../raw/index.html'>raw</a><br/><a class='mod ' href='../result/index.html'>result</a><br/><a class='mod ' href='../slice/index.html'>slice</a><br/><a class='mod ' href='../str/index.html'>str</a><br/><a class='mod ' href='../tuple/index.html'>tuple</a><br/><a class='mod ' href='../ty/index.html'>ty</a><br/><a class='mod ' href='../u16/index.html'>u16</a><br/><a class='mod ' href='../u32/index.html'>u32</a><br/><a class='mod ' href='../u64/index.html'>u64</a><br/><a class='mod ' href='../u8/index.html'>u8</a><br/><a class='mod ' href='../uint/index.html'>uint</a><br/></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'>Module <a href='../index.html'>core</a>::<a class='mod' href=''>ptr</a><a class='source' href='../../src/core/Users/richo/code/ext/rust/src/libcore/ptr.rs.html#13-736'>[src]</a></h1>
<div class='docblock'><p>Conveniences for working with unsafe pointers, the <code>*T</code>, and <code>*mut T</code> types.</p>

<p>Working with unsafe pointers in Rust is fairly uncommon,
and often limited to some narrow use cases: holding
an unsafe pointer when safe pointers are unsuitable;
checking for null; and converting back to safe pointers.
As a result, there is not yet an abundance of library code
for working with unsafe pointers, and in particular,
since pointer math is fairly uncommon in Rust, it is not
all that convenient.</p>

<p>Use the <a href="fn.null.html"><code>null</code> function</a> to create null pointers,
the <a href="trait.RawPtr.html#tymethod.is_null"><code>is_null</code></a>
and <a href="trait.RawPtr.html#method.is_not_null"><code>is_not_null</code></a>
methods of the <a href="trait.RawPtr.html"><code>RawPtr</code> trait</a> to check for null.
The <code>RawPtr</code> trait is imported by the prelude, so <code>is_null</code> etc.
work everywhere.</p>

<h1 id="common-ways-to-create-unsafe-pointers" class='section-header'><a
                           href="#common-ways-to-create-unsafe-pointers">Common ways to create unsafe pointers</a></h1>
<h2 id="1.-coerce-a-reference-(&amp;t)-or-mutable-reference-(&amp;mut-t)." class='section-header'><a
                           href="#1.-coerce-a-reference-(&amp;t)-or-mutable-reference-(&amp;mut-t).">1. Coerce a reference (<code>&amp;T</code>) or mutable reference (<code>&amp;mut T</code>).</a></h2><pre class='rust '>
<span class='kw'>let</span> <span class='ident'>my_num</span>: <span class='ident'>int</span> <span class='op'>=</span> <span class='number'>10</span>;
<span class='kw'>let</span> <span class='ident'>my_num_ptr</span>: <span class='op'>*</span><span class='ident'>int</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>my_num</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>my_speed</span>: <span class='ident'>int</span> <span class='op'>=</span> <span class='number'>88</span>;
<span class='kw'>let</span> <span class='ident'>my_speed_ptr</span>: <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>int</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>my_speed</span>;
</pre>

<p>This does not take ownership of the original allocation
and requires no resource management later,
but you must not use the pointer after its lifetime.</p>

<h2 id="2.-transmute-an-owned-box-(box&lt;t&gt;)." class='section-header'><a
                           href="#2.-transmute-an-owned-box-(box&lt;t&gt;).">2. Transmute an owned box (<code>Box&lt;T&gt;</code>).</a></h2>
<p>The <code>transmute</code> function takes, by value, whatever it&#39;s given
and returns it as whatever type is requested, as long as the
types are the same size. Because <code>Box&lt;T&gt;</code> and <code>*T</code> have the same
representation they can be trivially,
though unsafely, transformed from one type to the other.</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>mem</span>;

<span class='kw'>unsafe</span> {
    <span class='kw'>let</span> <span class='ident'>my_num</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='number'>10</span>;
    <span class='kw'>let</span> <span class='ident'>my_num</span>: <span class='op'>*</span><span class='ident'>int</span> <span class='op'>=</span> <span class='ident'>mem</span>::<span class='ident'>transmute</span>(<span class='ident'>my_num</span>);
    <span class='kw'>let</span> <span class='ident'>my_speed</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='number'>88</span>;
    <span class='kw'>let</span> <span class='ident'>my_speed</span>: <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>int</span> <span class='op'>=</span> <span class='ident'>mem</span>::<span class='ident'>transmute</span>(<span class='ident'>my_speed</span>);<span class='comment'>

    // By taking ownership of the original `Box&lt;T&gt;` though
    // we are obligated to transmute it back later to be destroyed.
    </span><span class='ident'>drop</span>(<span class='ident'>mem</span>::<span class='ident'>transmute</span>::<span class='op'>&lt;</span>_, <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;&gt;</span>(<span class='ident'>my_speed</span>));
    <span class='ident'>drop</span>(<span class='ident'>mem</span>::<span class='ident'>transmute</span>::<span class='op'>&lt;</span>_, <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;&gt;</span>(<span class='ident'>my_num</span>));
}
</pre>

<p>Note that here the call to <code>drop</code> is for clarity - it indicates
that we are done with the given value and it should be destroyed.</p>

<h2 id="3.-get-it-from-c." class='section-header'><a
                           href="#3.-get-it-from-c.">3. Get it from C.</a></h2><pre class='rust '>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>libc</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>mem</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>unsafe</span> {
        <span class='kw'>let</span> <span class='ident'>my_num</span>: <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>int</span> <span class='op'>=</span> <span class='ident'>libc</span>::<span class='ident'>malloc</span>(<span class='ident'>mem</span>::<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span>() <span class='kw'>as</span> <span class='ident'>libc</span>::<span class='ident'>size_t</span>) <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>int</span>;
        <span class='kw'>if</span> <span class='ident'>my_num</span>.<span class='ident'>is_null</span>() {
            <span class='macro'>fail</span><span class='macro'>!</span>(<span class='string'>&quot;failed to allocate memory&quot;</span>);
        }
        <span class='ident'>libc</span>::<span class='ident'>free</span>(<span class='ident'>my_num</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>libc</span>::<span class='ident'>c_void</span>);
    }
}
</pre>

<p>Usually you wouldn&#39;t literally use <code>malloc</code> and <code>free</code> from Rust,
but C APIs hand out a lot of pointers generally, so are a common source
of unsafe pointers in Rust.</p>
</div><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                    <tr>
                        <td><a class='trait' href='trait.RawPtr.html'
                               title='core::ptr::RawPtr'>RawPtr</a></td>
                        <td class='docblock short'><p>Extension methods for raw pointers.</p>
</td>
                    </tr>
                </table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                    <tr>
                        <td><a class='fn' href='fn.array_each.html'
                               title='core::ptr::array_each'>array_each</a></td>
                        <td class='docblock short'><p>Given a null-pointer-terminated **T (pointer to
an array of pointers), iterate through each *T,
passing to the provided callback function</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.array_each_with_len.html'
                               title='core::ptr::array_each_with_len'>array_each_with_len</a></td>
                        <td class='docblock short'><p>Given a **T (pointer to an array of pointers),
iterate through each *T, up to the provided <code>len</code>,
passing to the provided callback function</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.buf_len.html'
                               title='core::ptr::buf_len'>buf_len</a></td>
                        <td class='docblock short'><p>Return the offset of the first null pointer in <code>buf</code>.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.copy_memory.html'
                               title='core::ptr::copy_memory'>copy_memory</a></td>
                        <td class='docblock short'><p>Copies data from one location to another.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.copy_nonoverlapping_memory.html'
                               title='core::ptr::copy_nonoverlapping_memory'>copy_nonoverlapping_memory</a></td>
                        <td class='docblock short'><p>Copies data from one location to another.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.mut_null.html'
                               title='core::ptr::mut_null'>mut_null</a></td>
                        <td class='docblock short'><p>Create an unsafe mutable null pointer.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.null.html'
                               title='core::ptr::null'>null</a></td>
                        <td class='docblock short'><p>Create a null pointer.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.position.html'
                               title='core::ptr::position'>position</a></td>
                        <td class='docblock short'><p>Return the first offset <code>i</code> such that <code>f(buf[i]) == true</code>.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.read.html'
                               title='core::ptr::read'>read</a></td>
                        <td class='docblock short'><p>Reads the value from <code>*src</code> and returns it.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.read_and_zero.html'
                               title='core::ptr::read_and_zero'>read_and_zero</a></td>
                        <td class='docblock short'><p>Reads the value from <code>*src</code> and nulls it out.
This currently prevents destructors from executing.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.replace.html'
                               title='core::ptr::replace'>replace</a></td>
                        <td class='docblock short'><p>Replace the value at a mutable location with a new one, returning the old
value, without deinitialising either.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.set_memory.html'
                               title='core::ptr::set_memory'>set_memory</a></td>
                        <td class='docblock short'><p>Invokes memset on the specified pointer, setting <code>count * size_of::&lt;T&gt;()</code>
bytes of memory starting at <code>dst</code> to <code>c</code>.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.swap.html'
                               title='core::ptr::swap'>swap</a></td>
                        <td class='docblock short'><p>Swap the values at two mutable locations of the same type, without
deinitialising either. They may overlap.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.zero_memory.html'
                               title='core::ptr::zero_memory'>zero_memory</a></td>
                        <td class='docblock short'><p>Zeroes out <code>count * size_of::&lt;T&gt;</code> bytes of memory at <code>dst</code></p>
</td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    <script>
        var rootPath = "../../";
        var currentCrate = "core";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>