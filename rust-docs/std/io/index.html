<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The std library documentation.">

    <title>std::io - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,600'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico">
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        
            <a href='../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        

        <p class='location'><a href='../index.html'>std</a></p><div class='block mod'><h2>Modules</h2><a class='mod ' href='../ascii/index.html'>ascii</a><br/><a class='mod ' href='../bitflags/index.html'>bitflags</a><br/><a class='mod ' href='../c_str/index.html'>c_str</a><br/><a class='mod ' href='../c_vec/index.html'>c_vec</a><br/><a class='mod ' href='../comm/index.html'>comm</a><br/><a class='mod ' href='../f32/index.html'>f32</a><br/><a class='mod ' href='../f64/index.html'>f64</a><br/><a class='mod ' href='../fmt/index.html'>fmt</a><br/><a class='mod ' href='../from_str/index.html'>from_str</a><br/><a class='mod ' href='../gc/index.html'>gc</a><br/><a class='mod ' href='../hash/index.html'>hash</a><br/><a class='mod ' href='../i16/index.html'>i16</a><br/><a class='mod ' href='../i32/index.html'>i32</a><br/><a class='mod ' href='../i64/index.html'>i64</a><br/><a class='mod ' href='../i8/index.html'>i8</a><br/><a class='mod ' href='../int/index.html'>int</a><br/><a class='mod current' href='../io/index.html'>io</a><br/><a class='mod ' href='../local_data/index.html'>local_data</a><br/><a class='mod ' href='../macros/index.html'>macros</a><br/><a class='mod ' href='../num/index.html'>num</a><br/><a class='mod ' href='../option/index.html'>option</a><br/><a class='mod ' href='../os/index.html'>os</a><br/><a class='mod ' href='../path/index.html'>path</a><br/><a class='mod ' href='../prelude/index.html'>prelude</a><br/><a class='mod ' href='../rc/index.html'>rc</a><br/><a class='mod ' href='../reflect/index.html'>reflect</a><br/><a class='mod ' href='../repr/index.html'>repr</a><br/><a class='mod ' href='../result/index.html'>result</a><br/><a class='mod ' href='../rt/index.html'>rt</a><br/><a class='mod ' href='../slice/index.html'>slice</a><br/><a class='mod ' href='../str/index.html'>str</a><br/><a class='mod ' href='../strbuf/index.html'>strbuf</a><br/><a class='mod ' href='../sync/index.html'>sync</a><br/><a class='mod ' href='../task/index.html'>task</a><br/><a class='mod ' href='../to_str/index.html'>to_str</a><br/><a class='mod ' href='../u16/index.html'>u16</a><br/><a class='mod ' href='../u32/index.html'>u32</a><br/><a class='mod ' href='../u64/index.html'>u64</a><br/><a class='mod ' href='../u8/index.html'>u8</a><br/><a class='mod ' href='../uint/index.html'>uint</a><br/><a class='mod ' href='../vec/index.html'>vec</a><br/></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'>Module <a href='../index.html'>std</a>::<a class='mod' href=''>io</a><a class='source' href='../../src/std/src/libstd/io/mod.rs.html#17-1618'>[src]</a></h1>
<div class='docblock'><p>I/O, including files, networking, timers, and processes</p>

<p><code>std::io</code> provides Rust&#39;s basic I/O types,
for reading and writing to files, TCP, UDP,
and other types of sockets and pipes,
manipulating the file system, spawning processes and signal handling.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1>
<p>Some examples of obvious things you might want to do</p>

<ul>
<li><p>Read lines from stdin</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;

<span class='kw'>for</span> <span class='ident'>line</span> <span class='kw'>in</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>lines</span>() {
    <span class='macro'>print</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>line</span>.<span class='ident'>unwrap</span>());
}
</pre></li>
<li><p>Read a complete file</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>File</span>;

<span class='kw'>let</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>open</span>(<span class='kw-2'>&amp;</span><span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='string'>&quot;message.txt&quot;</span>)).<span class='ident'>read_to_end</span>();
</pre></li>
<li><p>Write a line to a file</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>File</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>create</span>(<span class='kw-2'>&amp;</span><span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='string'>&quot;message.txt&quot;</span>));
<span class='ident'>file</span>.<span class='ident'>write</span>(<span class='macro'>bytes</span><span class='macro'>!</span>(<span class='string'>&quot;hello, file!\n&quot;</span>));
</pre></li>
<li><p>Iterate over the lines of a file</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>BufferedReader</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>File</span>;

<span class='kw'>let</span> <span class='ident'>path</span> <span class='op'>=</span> <span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='string'>&quot;message.txt&quot;</span>);
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='ident'>BufferedReader</span>::<span class='ident'>new</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='kw-2'>&amp;</span><span class='ident'>path</span>));
<span class='kw'>for</span> <span class='ident'>line</span> <span class='kw'>in</span> <span class='ident'>file</span>.<span class='ident'>lines</span>() {
    <span class='macro'>print</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>line</span>.<span class='ident'>unwrap</span>());
}
</pre></li>
<li><p>Pull the lines of a file into a vector of strings</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>BufferedReader</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>File</span>;

<span class='kw'>let</span> <span class='ident'>path</span> <span class='op'>=</span> <span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='string'>&quot;message.txt&quot;</span>);
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='ident'>BufferedReader</span>::<span class='ident'>new</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='kw-2'>&amp;</span><span class='ident'>path</span>));
<span class='kw'>let</span> <span class='ident'>lines</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='kw-2'>~</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>file</span>.<span class='ident'>lines</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span>.<span class='ident'>unwrap</span>()).<span class='ident'>collect</span>();
</pre></li>
<li><p>Make a simple TCP client connection and request</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>net</span>::<span class='ident'>ip</span>::<span class='ident'>SocketAddr</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>net</span>::<span class='ident'>tcp</span>::<span class='ident'>TcpStream</span>;

<span class='kw'>let</span> <span class='ident'>addr</span> <span class='op'>=</span> <span class='ident'>from_str</span>::<span class='op'>&lt;</span><span class='ident'>SocketAddr</span><span class='op'>&gt;</span>(<span class='string'>&quot;127.0.0.1:8080&quot;</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>socket</span> <span class='op'>=</span> <span class='ident'>TcpStream</span>::<span class='ident'>connect</span>(<span class='ident'>addr</span>).<span class='ident'>unwrap</span>();
<span class='ident'>socket</span>.<span class='ident'>write</span>(<span class='macro'>bytes</span><span class='macro'>!</span>(<span class='string'>&quot;GET / HTTP/1.0\n\n&quot;</span>));
<span class='kw'>let</span> <span class='ident'>response</span> <span class='op'>=</span> <span class='ident'>socket</span>.<span class='ident'>read_to_end</span>();
</pre></li>
<li><p>Make a simple TCP server</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>TcpListener</span>, <span class='ident'>TcpStream</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>net</span>::<span class='ident'>ip</span>::{<span class='ident'>Ipv4Addr</span>, <span class='ident'>SocketAddr</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>Acceptor</span>, <span class='ident'>Listener</span>};

<span class='kw'>let</span> <span class='ident'>addr</span> <span class='op'>=</span> <span class='ident'>SocketAddr</span> { <span class='ident'>ip</span>: <span class='ident'>Ipv4Addr</span>(<span class='number'>127</span>, <span class='number'>0</span>, <span class='number'>0</span>, <span class='number'>1</span>), <span class='ident'>port</span>: <span class='number'>80</span> };
<span class='kw'>let</span> <span class='ident'>listener</span> <span class='op'>=</span> <span class='ident'>TcpListener</span>::<span class='ident'>bind</span>(<span class='ident'>addr</span>);<span class='comment'>

// bind the listener to the specified address
</span><span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>acceptor</span> <span class='op'>=</span> <span class='ident'>listener</span>.<span class='ident'>listen</span>();

<span class='kw'>fn</span> <span class='ident'>handle_client</span>(<span class='kw-2'>mut</span> <span class='ident'>stream</span>: <span class='ident'>TcpStream</span>) {<span class='comment'>
    // ...
</span>}<span class='comment'>
// accept connections and process them, spawning a new tasks for each one
</span><span class='kw'>for</span> <span class='ident'>stream</span> <span class='kw'>in</span> <span class='ident'>acceptor</span>.<span class='ident'>incoming</span>() {
    <span class='kw'>match</span> <span class='ident'>stream</span> {
        <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> {<span class='comment'> /* connection failed */ </span>}
        <span class='prelude-val'>Ok</span>(<span class='ident'>stream</span>) <span class='op'>=&gt;</span> <span class='ident'>spawn</span>(<span class='kw'>proc</span>() {<span class='comment'>
            // connection succeeded
            </span><span class='ident'>handle_client</span>(<span class='ident'>stream</span>)
        })
    }
}<span class='comment'>

// close the socket server
</span><span class='ident'>drop</span>(<span class='ident'>acceptor</span>);
</pre></li>
</ul>

<h1 id="error-handling" class='section-header'><a
                           href="#error-handling">Error Handling</a></h1>
<p>I/O is an area where nearly every operation can result in unexpected
errors. Errors should be painfully visible when they happen, and handling them
should be easy to work with. It should be convenient to handle specific I/O
errors, and it should also be convenient to not deal with I/O errors.</p>

<p>Rust&#39;s I/O employs a combination of techniques to reduce boilerplate
while still providing feedback about errors. The basic strategy:</p>

<ul>
<li>All I/O operations return <code>IoResult&lt;T&gt;</code> which is equivalent to
<code>Result&lt;T, IoError&gt;</code>. The <code>Result</code> type is defined in the <code>std::result</code>
module.</li>
<li>If the <code>Result</code> type goes unused, then the compiler will by default emit a
warning about the unused result. This is because <code>Result</code> has the
<code>#[must_use]</code> attribute.</li>
<li>Common traits are implemented for <code>IoResult</code>, e.g.
<code>impl&lt;R: Reader&gt; Reader for IoResult&lt;R&gt;</code>, so that error values do not have
to be &#39;unwrapped&#39; before use.</li>
</ul>

<p>These features combine in the API to allow for expressions like
<code>File::create(&amp;Path::new(&quot;diary.txt&quot;)).write(bytes!(&quot;Met a girl.\n&quot;))</code>
without having to worry about whether &quot;diary.txt&quot; exists or whether
the write succeeds. As written, if either <code>new</code> or <code>write_line</code>
encounters an error then the result of the entire expression will
be an error.</p>

<p>If you wanted to handle the error though you might write:</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>File</span>;

<span class='kw'>match</span> <span class='ident'>File</span>::<span class='ident'>create</span>(<span class='kw-2'>&amp;</span><span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='string'>&quot;diary.txt&quot;</span>)).<span class='ident'>write</span>(<span class='macro'>bytes</span><span class='macro'>!</span>(<span class='string'>&quot;Met a girl.\n&quot;</span>)) {
    <span class='prelude-val'>Ok</span>(()) <span class='op'>=&gt;</span> (),<span class='comment'> // succeeded
    </span><span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;failed to write to my diary: {}&quot;</span>, <span class='ident'>e</span>),
}
</pre>

<p>So what actually happens if <code>create</code> encounters an error?
It&#39;s important to know that what <code>new</code> returns is not a <code>File</code>
but an <code>IoResult&lt;File&gt;</code>.  If the file does not open, then <code>new</code> will simply
return <code>Err(..)</code>. Because there is an implementation of <code>Writer</code> (the trait
required ultimately required for types to implement <code>write_line</code>) there is no
need to inspect or unwrap the <code>IoResult&lt;File&gt;</code> and we simply call <code>write_line</code>
on it. If <code>new</code> returned an <code>Err(..)</code> then the followup call to <code>write_line</code>
will also return an error.</p>

<h2 id="try!" class='section-header'><a
                           href="#try!"><code>try!</code></a></h2>
<p>Explicit pattern matching on <code>IoResult</code>s can get quite verbose, especially
when performing many I/O operations. Some examples (like those above) are
alleviated with extra methods implemented on <code>IoResult</code>, but others have more
complex interdependencies among each I/O operation.</p>

<p>The <code>try!</code> macro from <code>std::macros</code> is provided as a method of early-return
inside <code>Result</code>-returning functions. It expands to an early-return on <code>Err</code>
and otherwise unwraps the contained <code>Ok</code> value.</p>

<p>If you wanted to read several <code>u32</code>s from a file and return their product:</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>File</span>, <span class='ident'>IoResult</span>};

<span class='kw'>fn</span> <span class='ident'>file_product</span>(<span class='ident'>p</span>: <span class='kw-2'>&amp;</span><span class='ident'>Path</span>) <span class='op'>-&gt;</span> <span class='ident'>IoResult</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>p</span>);
    <span class='kw'>let</span> <span class='ident'>x1</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>read_le_u32</span>());
    <span class='kw'>let</span> <span class='ident'>x2</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>read_le_u32</span>());

    <span class='prelude-val'>Ok</span>(<span class='ident'>x1</span> <span class='op'>*</span> <span class='ident'>x2</span>)
}

<span class='kw'>match</span> <span class='ident'>file_product</span>(<span class='kw-2'>&amp;</span><span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='string'>&quot;numbers.bin&quot;</span>)) {
    <span class='prelude-val'>Ok</span>(<span class='ident'>x</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>),
    <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Failed to read numbers!&quot;</span>)
}
</pre>

<p>With <code>try!</code> in <code>file_product</code>, each <code>read_le_u32</code> need not be directly
concerned with error handling; instead its caller is responsible for
responding to errors that may occur while attempting to read the numbers.</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Reexports</a></h2>
<table><tr><td><code>pub use self::<a class='mod'
                                            href='./stdio/index.html'>stdio</a>::<a class='fn' href='../../std/io/stdio/fn.stdin.html' title='std::io::stdio::stdin'>stdin</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./stdio/index.html'>stdio</a>::<a class='fn' href='../../std/io/stdio/fn.stdout.html' title='std::io::stdio::stdout'>stdout</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./stdio/index.html'>stdio</a>::<a class='fn' href='../../std/io/stdio/fn.stderr.html' title='std::io::stdio::stderr'>stderr</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./stdio/index.html'>stdio</a>::<a class='fn' href='../../std/io/stdio/fn.print.html' title='std::io::stdio::print'>print</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./stdio/index.html'>stdio</a>::<a class='fn' href='../../std/io/stdio/fn.println.html' title='std::io::stdio::println'>println</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./fs/index.html'>fs</a>::<a class='struct' href='../../std/io/fs/struct.File.html' title='std::io::fs::File'>File</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./timer/index.html'>timer</a>::<a class='struct' href='../../std/io/timer/struct.Timer.html' title='std::io::timer::Timer'>Timer</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./net/index.html'>net</a>::<a class='mod'
                                            href='./net/ip/index.html'>ip</a>::<a class='type' href='../../std/io/net/ip/type.IpAddr.html' title='std::io::net::ip::IpAddr'>IpAddr</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./net/index.html'>net</a>::<a class='mod'
                                            href='./net/tcp/index.html'>tcp</a>::<a class='struct' href='../../std/io/net/tcp/struct.TcpListener.html' title='std::io::net::tcp::TcpListener'>TcpListener</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./net/index.html'>net</a>::<a class='mod'
                                            href='./net/tcp/index.html'>tcp</a>::<a class='struct' href='../../std/io/net/tcp/struct.TcpStream.html' title='std::io::net::tcp::TcpStream'>TcpStream</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./net/index.html'>net</a>::<a class='mod'
                                            href='./net/udp/index.html'>udp</a>::<a class='struct' href='../../std/io/net/udp/struct.UdpStream.html' title='std::io::net::udp::UdpStream'>UdpStream</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./pipe/index.html'>pipe</a>::<a class='struct' href='../../std/io/pipe/struct.PipeStream.html' title='std::io::pipe::PipeStream'>PipeStream</a>;</code></td></tr><tr><td><code>pub use self::process::{<a class='struct' href='../../std/io/process/struct.Process.html' title='std::io::process::Process'>Process</a>, <a class='struct' href='../../std/io/process/struct.ProcessConfig.html' title='std::io::process::ProcessConfig'>ProcessConfig</a>};</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                    <tr>
                        <td><a class='mod' href='extensions/index.html'
                               title='std::io::extensions'>extensions</a></td>
                        <td class='docblock short'><p>Utility mixins that apply to all Readers and Writers</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='mod' href='fs/index.html'
                               title='std::io::fs'>fs</a></td>
                        <td class='docblock short'><p>Synchronous File I/O</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='mod' href='net/index.html'
                               title='std::io::net'>net</a></td>
                        <td class='docblock short'><p>Networking I/O</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='mod' href='pipe/index.html'
                               title='std::io::pipe'>pipe</a></td>
                        <td class='docblock short'><p>Synchronous, in-memory pipes.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='mod' href='process/index.html'
                               title='std::io::process'>process</a></td>
                        <td class='docblock short'><p>Bindings for executing child processes</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='mod' href='signal/index.html'
                               title='std::io::signal'>signal</a></td>
                        <td class='docblock short'><p>Signal handling</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='mod' href='stdio/index.html'
                               title='std::io::stdio'>stdio</a></td>
                        <td class='docblock short'><p>Non-blocking access to stdin, stdout, and stderr.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='mod' href='test/index.html'
                               title='std::io::test'>test</a></td>
                        <td class='docblock short'><p>Various utility functions useful for writing I/O tests</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='mod' href='timer/index.html'
                               title='std::io::timer'>timer</a></td>
                        <td class='docblock short'><p>Synchronous Timers</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='mod' href='util/index.html'
                               title='std::io::util'>util</a></td>
                        <td class='docblock short'><p>Utility implementations of Reader and Writer</p>
</td>
                    </tr>
                </table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                    <tr>
                        <td><a class='struct' href='struct.BufReader.html'
                               title='std::io::BufReader'>BufReader</a></td>
                        <td class='docblock short'><p>Reads from a fixed-size byte slice</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.BufWriter.html'
                               title='std::io::BufWriter'>BufWriter</a></td>
                        <td class='docblock short'><p>Writes to a fixed-size byte slice</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.BufferedReader.html'
                               title='std::io::BufferedReader'>BufferedReader</a></td>
                        <td class='docblock short'><p>Wraps a Reader and buffers input from it</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.BufferedStream.html'
                               title='std::io::BufferedStream'>BufferedStream</a></td>
                        <td class='docblock short'><p>Wraps a Stream and buffers input and output to and from it.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.BufferedWriter.html'
                               title='std::io::BufferedWriter'>BufferedWriter</a></td>
                        <td class='docblock short'><p>Wraps a Writer and buffers output to it</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.ChanReader.html'
                               title='std::io::ChanReader'>ChanReader</a></td>
                        <td class='docblock short'><p>Allows reading from a rx.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.ChanWriter.html'
                               title='std::io::ChanWriter'>ChanWriter</a></td>
                        <td class='docblock short'><p>Allows writing to a tx.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.Chars.html'
                               title='std::io::Chars'>Chars</a></td>
                        <td class='docblock short'><p>An iterator that reads a utf8-encoded character on each iteration,
until <code>.read_char()</code> encounters <code>EndOfFile</code>.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.FilePermission.html'
                               title='std::io::FilePermission'>FilePermission</a></td>
                        <td class='docblock short'><p>A set of permissions for a file or directory is represented
by a set of flags which are or&#39;d together.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.FileStat.html'
                               title='std::io::FileStat'>FileStat</a></td>
                        <td class='docblock short'><p>A structure used to describe metadata information about a file. This
structure is created through the <code>stat</code> method on a <code>Path</code>.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.IncomingConnections.html'
                               title='std::io::IncomingConnections'>IncomingConnections</a></td>
                        <td class='docblock short'><p>An infinite iterator over incoming connection attempts.
Calling <code>next</code> will block the task until a connection is attempted.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.IoError.html'
                               title='std::io::IoError'>IoError</a></td>
                        <td class='docblock short'><p>The type passed to I/O condition handlers to indicate error</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.LineBufferedWriter.html'
                               title='std::io::LineBufferedWriter'>LineBufferedWriter</a></td>
                        <td class='docblock short'><p>Wraps a Writer and buffers output to it, flushing whenever a newline (<code>0x0a</code>,
<code>&#39;\n&#39;</code>) is detected.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.Lines.html'
                               title='std::io::Lines'>Lines</a></td>
                        <td class='docblock short'><p>An iterator that reads a line on each iteration,
until <code>.read_line()</code> encounters <code>EndOfFile</code>.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.MemReader.html'
                               title='std::io::MemReader'>MemReader</a></td>
                        <td class='docblock short'><p>Reads from an owned byte vector</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.MemWriter.html'
                               title='std::io::MemWriter'>MemWriter</a></td>
                        <td class='docblock short'><p>Writes to an owned, growable byte vector</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.RefReader.html'
                               title='std::io::RefReader'>RefReader</a></td>
                        <td class='docblock short'><p>A <code>RefReader</code> is a struct implementing <code>Reader</code> which contains a reference
to another reader. This is often useful when composing streams.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.RefWriter.html'
                               title='std::io::RefWriter'>RefWriter</a></td>
                        <td class='docblock short'><p>A <code>RefWriter</code> is a struct implementing <code>Writer</code> which contains a reference
to another writer. This is often useful when composing streams.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.TempDir.html'
                               title='std::io::TempDir'>TempDir</a></td>
                        <td class='docblock short'><p>A wrapper for a path to temporary directory implementing automatic
scope-based deletion.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.UnstableFileStat.html'
                               title='std::io::UnstableFileStat'>UnstableFileStat</a></td>
                        <td class='docblock short'><p>This structure represents all of the possible information which can be
returned from a <code>stat</code> syscall which is not contained in the <code>FileStat</code>
structure. This information is not necessarily platform independent, and may
have different meanings or no meaning at all on some platforms.</p>
</td>
                    </tr>
                </table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                    <tr>
                        <td><a class='type' href='type.FileAccess.html'
                               title='std::io::FileAccess'>FileAccess</a></td>
                        <td class='docblock short'><p>Access permissions with which the file should be opened. <code>File</code>s
opened with <code>Read</code> will return an error if written to.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='type' href='type.FileMode.html'
                               title='std::io::FileMode'>FileMode</a></td>
                        <td class='docblock short'><p>A mode specifies how a file should be opened or created. These modes are
passed to <code>File::open_mode</code> and are used to control where the file is
positioned when it is initially opened.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='type' href='type.FileType.html'
                               title='std::io::FileType'>FileType</a></td>
                        <td class='docblock short'><p>Different kinds of files which can be identified by a call to stat</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='type' href='type.IoErrorKind.html'
                               title='std::io::IoErrorKind'>IoErrorKind</a></td>
                        <td class='docblock short'><p>A list specifying general categories of I/O error.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='type' href='type.SeekStyle.html'
                               title='std::io::SeekStyle'>SeekStyle</a></td>
                        <td class='docblock short'><p>When seeking, the resulting cursor is offset from a base by the offset given
to the <code>seek</code> function. The base used is specified by this enumeration.</p>
</td>
                    </tr>
                </table><h2 id='statics' class='section-header'><a href="#statics">Statics</a></h2>
<table>
                    <tr>
                        <td><code>pub static AllPermissions: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'><p>All possible permissions enabled.</p>
&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><code>pub static GroupExecute: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><code>pub static GroupRWX: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><code>pub static GroupRead: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><code>pub static GroupWrite: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><code>pub static OtherExecute: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><code>pub static OtherRWX: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><code>pub static OtherRead: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><code>pub static OtherWrite: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><code>pub static UserDir: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'><p>Permissions for user owned directories, equivalent to 0755 on
unix-like systems.</p>
&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><code>pub static UserExec: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'><p>Permissions for user owned executables, equivalent to 0755
on unix-like systems.</p>
&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><code>pub static UserExecute: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><code>pub static UserFile: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'><p>Permissions for user owned files, equivalent to 0644 on
unix-like systems.</p>
&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><code>pub static UserRWX: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><code>pub static UserRead: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><code>pub static UserWrite: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                </table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                    <tr>
                        <td><a class='trait' href='trait.Acceptor.html'
                               title='std::io::Acceptor'>Acceptor</a></td>
                        <td class='docblock short'><p>An acceptor is a value that presents incoming connections</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.Buffer.html'
                               title='std::io::Buffer'>Buffer</a></td>
                        <td class='docblock short'><p>A Buffer is a type of reader which has some form of internal buffering to
allow certain kinds of reading operations to be more optimized than others.
This type extends the <code>Reader</code> trait with a few methods that are not
possible to reasonably implement with purely a read interface.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.Listener.html'
                               title='std::io::Listener'>Listener</a></td>
                        <td class='docblock short'><p>A listener is a value that can consume itself to start listening for
connections.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.Reader.html'
                               title='std::io::Reader'>Reader</a></td>
                        <td class='docblock short'><p>A trait for objects which are byte-oriented streams. Readers are defined by
one method, <code>read</code>. This function will block until data is available,
filling in the provided buffer with any data read.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.Seek.html'
                               title='std::io::Seek'>Seek</a></td>
                        <td class='docblock short'><p>An object implementing <code>Seek</code> internally has some form of cursor which can
be moved within a stream of bytes. The stream typically has a fixed size,
allowing seeking relative to either end.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.Stream.html'
                               title='std::io::Stream'>Stream</a></td>
                        <td class='docblock short'><p>A Stream is a readable and a writable object. Data written is typically
received by the object which reads receive data from.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.Writer.html'
                               title='std::io::Writer'>Writer</a></td>
                        <td class='docblock short'><p>A trait for objects which are byte-oriented streams. Writers are defined by
one method, <code>write</code>. This function will block until the provided buffer of
bytes has been entirely written, and it will return any failurs which occur.</p>
</td>
                    </tr>
                </table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                    <tr>
                        <td><a class='fn' href='fn.standard_error.html'
                               title='std::io::standard_error'>standard_error</a></td>
                        <td class='docblock short'><p>Creates a standard error for a commonly used flavor of error. The <code>detail</code>
field of the returned error will always be <code>None</code>.</p>
</td>
                    </tr>
                </table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table>
                    <tr>
                        <td><a class='type' href='type.IoResult.html'
                               title='std::io::IoResult'>IoResult</a></td>
                        <td class='docblock short'><p>A convenient typedef of the return value of any I/O action.</p>
</td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    <script>
        var rootPath = "../../";
        var currentCrate = "std";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>