<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The std library documentation.">

    <title>std::fmt - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,600'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico">
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        
            <a href='../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        

        <p class='location'><a href='../index.html'>std</a></p><div class='block mod'><h2>Modules</h2><a class='mod ' href='../ascii/index.html'>ascii</a><br/><a class='mod ' href='../bitflags/index.html'>bitflags</a><br/><a class='mod ' href='../c_str/index.html'>c_str</a><br/><a class='mod ' href='../c_vec/index.html'>c_vec</a><br/><a class='mod ' href='../comm/index.html'>comm</a><br/><a class='mod ' href='../f32/index.html'>f32</a><br/><a class='mod ' href='../f64/index.html'>f64</a><br/><a class='mod current' href='../fmt/index.html'>fmt</a><br/><a class='mod ' href='../from_str/index.html'>from_str</a><br/><a class='mod ' href='../gc/index.html'>gc</a><br/><a class='mod ' href='../hash/index.html'>hash</a><br/><a class='mod ' href='../i16/index.html'>i16</a><br/><a class='mod ' href='../i32/index.html'>i32</a><br/><a class='mod ' href='../i64/index.html'>i64</a><br/><a class='mod ' href='../i8/index.html'>i8</a><br/><a class='mod ' href='../int/index.html'>int</a><br/><a class='mod ' href='../io/index.html'>io</a><br/><a class='mod ' href='../local_data/index.html'>local_data</a><br/><a class='mod ' href='../macros/index.html'>macros</a><br/><a class='mod ' href='../num/index.html'>num</a><br/><a class='mod ' href='../option/index.html'>option</a><br/><a class='mod ' href='../os/index.html'>os</a><br/><a class='mod ' href='../path/index.html'>path</a><br/><a class='mod ' href='../prelude/index.html'>prelude</a><br/><a class='mod ' href='../rc/index.html'>rc</a><br/><a class='mod ' href='../reflect/index.html'>reflect</a><br/><a class='mod ' href='../repr/index.html'>repr</a><br/><a class='mod ' href='../result/index.html'>result</a><br/><a class='mod ' href='../rt/index.html'>rt</a><br/><a class='mod ' href='../slice/index.html'>slice</a><br/><a class='mod ' href='../str/index.html'>str</a><br/><a class='mod ' href='../strbuf/index.html'>strbuf</a><br/><a class='mod ' href='../sync/index.html'>sync</a><br/><a class='mod ' href='../task/index.html'>task</a><br/><a class='mod ' href='../to_str/index.html'>to_str</a><br/><a class='mod ' href='../u16/index.html'>u16</a><br/><a class='mod ' href='../u32/index.html'>u32</a><br/><a class='mod ' href='../u64/index.html'>u64</a><br/><a class='mod ' href='../u8/index.html'>u8</a><br/><a class='mod ' href='../uint/index.html'>uint</a><br/><a class='mod ' href='../vec/index.html'>vec</a><br/></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'>Module <a href='../index.html'>std</a>::<a class='mod' href=''>fmt</a><a class='source' href='../../src/std/src/libstd/fmt/mod.rs.html#11-1385'>[src]</a></h1>
<div class='docblock'><p>Utilities for formatting and printing strings</p>

<p>This module contains the runtime support for the <code>format!</code> syntax extension.
This macro is implemented in the compiler to emit calls to this module in order
to format arguments at runtime into strings and streams.</p>

<p>The functions contained in this module should not normally be used in everyday
use cases of <code>format!</code>. The assumptions made by these functions are unsafe for
all inputs, and the compiler performs a large amount of validation on the
arguments to <code>format!</code> in order to ensure safety at runtime. While it is
possible to call these functions directly, it is not recommended to do so in the
general case.</p>

<h2 id="usage" class='section-header'><a
                           href="#usage">Usage</a></h2>
<p>The <code>format!</code> macro is intended to be familiar to those coming from C&#39;s
printf/fprintf functions or Python&#39;s <code>str.format</code> function. In its current
revision, the <code>format!</code> macro returns a <code>~str</code> type which is the result of the
formatting. In the future it will also be able to pass in a stream to format
arguments directly while performing minimal allocations.</p>

<p>Some examples of the <code>format!</code> extension are:</p>
<pre class='rust '>
<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;Hello&quot;</span>);<span class='comment'>                 // =&gt; &quot;Hello&quot;.to_owned()
</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, {:s}!&quot;</span>, <span class='string'>&quot;world&quot;</span>);<span class='comment'> // =&gt; &quot;Hello, world!&quot;.to_owned()
</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;The number is {:d}&quot;</span>, <span class='number'>1</span>);<span class='comment'> // =&gt; &quot;The number is 1&quot;.to_owned()
</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='kw-2'>~</span>[<span class='number'>3</span>, <span class='number'>4</span>]);<span class='comment'>         // =&gt; &quot;~[3, 4]&quot;.to_owned()
</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{value}&quot;</span>, <span class='ident'>value</span><span class='op'>=</span><span class='number'>4</span>);<span class='comment'>      // =&gt; &quot;4&quot;.to_owned()
</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{} {}&quot;</span>, <span class='number'>1</span>, <span class='number'>2</span>);<span class='comment'>           // =&gt; &quot;1 2&quot;.to_owned()
</span></pre>

<p>From these, you can see that the first argument is a format string. It is
required by the compiler for this to be a string literal; it cannot be a
variable passed in (in order to perform validity checking). The compiler will
then parse the format string and determine if the list of arguments provided is
suitable to pass to this format string.</p>

<h3 id="positional-parameters" class='section-header'><a
                           href="#positional-parameters">Positional parameters</a></h3>
<p>Each formatting argument is allowed to specify which value argument it&#39;s
referencing, and if omitted it is assumed to be &quot;the next argument&quot;. For
example, the format string <code>{} {} {}</code> would take three parameters, and they
would be formatted in the same order as they&#39;re given. The format string
<code>{2} {1} {0}</code>, however, would format arguments in reverse order.</p>

<p>Things can get a little tricky once you start intermingling the two types of
positional specifiers. The &quot;next argument&quot; specifier can be thought of as an
iterator over the argument. Each time a &quot;next argument&quot; specifier is seen, the
iterator advances. This leads to behavior like this:</p>
<pre class='rust '>
<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{1} {} {0} {}&quot;</span>, <span class='number'>1</span>, <span class='number'>2</span>);<span class='comment'> // =&gt; &quot;2 1 1 2&quot;.to_owned()
</span></pre>

<p>The internal iterator over the argument has not been advanced by the time the
first <code>{}</code> is seen, so it prints the first argument. Then upon reaching the
second <code>{}</code>, the iterator has advanced forward to the second argument.
Essentially, parameters which explicitly name their argument do not affect
parameters which do not name an argument in terms of positional specifiers.</p>

<p>A format string is required to use all of its arguments, otherwise it is a
compile-time error. You may refer to the same argument more than once in the
format string, although it must always be referred to with the same type.</p>

<h3 id="named-parameters" class='section-header'><a
                           href="#named-parameters">Named parameters</a></h3>
<p>Rust itself does not have a Python-like equivalent of named parameters to a
function, but the <code>format!</code> macro is a syntax extension which allows it to
leverage named parameters. Named parameters are listed at the end of the
argument list and have the syntax:</p>

<pre><code class="language-notrust">identifier &#39;=&#39; expression</code></pre>

<p>For example, the following <code>format!</code> expressions all use named argument:</p>
<pre class='rust '>
<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{argument}&quot;</span>, <span class='ident'>argument</span> <span class='op'>=</span> <span class='string'>&quot;test&quot;</span>);<span class='comment'>       // =&gt; &quot;test&quot;.to_owned()
</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{name} {}&quot;</span>, <span class='number'>1</span>, <span class='ident'>name</span> <span class='op'>=</span> <span class='number'>2</span>);<span class='comment'>              // =&gt; &quot;2 1&quot;.to_owned()
</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{a:s} {c:d} {b:?}&quot;</span>, <span class='ident'>a</span><span class='op'>=</span><span class='string'>&quot;a&quot;</span>, <span class='ident'>b</span><span class='op'>=</span>(), <span class='ident'>c</span><span class='op'>=</span><span class='number'>3</span>);<span class='comment'> // =&gt; &quot;a 3 ()&quot;.to_owned()
</span></pre>

<p>It is illegal to put positional parameters (those without names) after arguments
which have names. Like positional parameters, it is illegal to provided named
parameters that are unused by the format string.</p>

<h3 id="argument-types" class='section-header'><a
                           href="#argument-types">Argument types</a></h3>
<p>Each argument&#39;s type is dictated by the format string. It is a requirement that
every argument is only ever referred to by one type. When specifying the format
of an argument, however, a string like <code>{}</code> indicates no type. This is allowed,
and if all references to one argument do not provide a type, then the format <code>?</code>
is used (the type&#39;s rust-representation is printed). For example, this is an
invalid format string:</p>

<pre><code class="language-notrust">{0:d} {0:s}</code></pre>

<p>Because the first argument is both referred to as an integer as well as a
string.</p>

<p>Because formatting is done via traits, there is no requirement that the
<code>d</code> format actually takes an <code>int</code>, but rather it simply requires a type which
ascribes to the <code>Signed</code> formatting trait. There are various parameters which do
require a particular type, however. Namely if the syntax <code>{:.*s}</code> is used, then
the number of characters to print from the string precedes the actual string and
must have the type <code>uint</code>. Although a <code>uint</code> can be printed with <code>{:u}</code>, it is
illegal to reference an argument as such. For example, this is another invalid
format string:</p>

<pre><code class="language-notrust">{:.*s} {0:u}</code></pre>

<h3 id="formatting-traits" class='section-header'><a
                           href="#formatting-traits">Formatting traits</a></h3>
<p>When requesting that an argument be formatted with a particular type, you are
actually requesting that an argument ascribes to a particular trait. This allows
multiple actual types to be formatted via <code>{:d}</code> (like <code>i8</code> as well as <code>int</code>).
The current mapping of types to traits is:</p>

<ul>
<li><code>?</code> ⇒ <code>Poly</code></li>
<li><code>d</code> ⇒ <code>Signed</code></li>
<li><code>i</code> ⇒ <code>Signed</code></li>
<li><code>u</code> ⇒ <code>Unsigned</code></li>
<li><code>b</code> ⇒ <code>Bool</code></li>
<li><code>c</code> ⇒ <code>Char</code></li>
<li><code>o</code> ⇒ <code>Octal</code></li>
<li><code>x</code> ⇒ <code>LowerHex</code></li>
<li><code>X</code> ⇒ <code>UpperHex</code></li>
<li><code>s</code> ⇒ <code>String</code></li>
<li><code>p</code> ⇒ <code>Pointer</code></li>
<li><code>t</code> ⇒ <code>Binary</code></li>
<li><code>f</code> ⇒ <code>Float</code></li>
<li><code>e</code> ⇒ <code>LowerExp</code></li>
<li><code>E</code> ⇒ <code>UpperExp</code></li>
<li><em>nothing</em> ⇒ <code>Show</code></li>
</ul>

<p>What this means is that any type of argument which implements the
<code>std::fmt::Binary</code> trait can then be formatted with <code>{:t}</code>. Implementations are
provided for these traits for a number of primitive types by the standard
library as well. If no format is specified (as in <code>{}</code> or <code>{:6}</code>), then the
format trait used is the <code>Show</code> trait. This is one of the more commonly
implemented traits when formatting a custom type.</p>

<p>When implementing a format trait for your own type, you will have to implement a
method of the signature:</p>
<pre class='rust '>
<span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='ident'>fmt</span>::<span class='prelude-ty'>Result</span>;
</pre>

<p>Your type will be passed as <code>self</code> by-reference, and then the function should
emit output into the <code>f.buf</code> stream. It is up to each format trait
implementation to correctly adhere to the requested formatting parameters. The
values of these parameters will be listed in the fields of the <code>Formatter</code>
struct. In order to help with this, the <code>Formatter</code> struct also provides some
helper methods.</p>

<p>Additionally, the return value of this function is <code>fmt::Result</code> which is a
typedef to <code>Result&lt;(), IoError&gt;</code> (also known as <code>IoError&lt;()&gt;</code>). Formatting
implementations should ensure that they return errors from <code>write!</code> correctly
(propagating errors upward).</p>

<p>An example of implementing the formatting traits would look
like:</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>f64</span>;

<span class='kw'>struct</span> <span class='ident'>Vector2D</span> {
    <span class='ident'>x</span>: <span class='ident'>int</span>,
    <span class='ident'>y</span>: <span class='ident'>int</span>,
}

<span class='kw'>impl</span> <span class='ident'>fmt</span>::<span class='ident'>Show</span> <span class='kw'>for</span> <span class='ident'>Vector2D</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>fmt</span>::<span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='ident'>fmt</span>::<span class='prelude-ty'>Result</span> {<span class='comment'>
        // The `f.buf` value is of the type `&amp;mut io::Writer`, which is what the
        // write! macro is expecting. Note that this formatting ignores the
        // various flags provided to format strings.
        </span><span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>buf</span>, <span class='string'>&quot;({}, {})&quot;</span>, <span class='self'>self</span>.<span class='ident'>x</span>, <span class='self'>self</span>.<span class='ident'>y</span>)
    }
}<span class='comment'>

// Different traits allow different forms of output of a type. The meaning of
// this format is to print the magnitude of a vector.
</span><span class='kw'>impl</span> <span class='ident'>fmt</span>::<span class='ident'>Binary</span> <span class='kw'>for</span> <span class='ident'>Vector2D</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>fmt</span>::<span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='ident'>fmt</span>::<span class='prelude-ty'>Result</span> {
        <span class='kw'>let</span> <span class='ident'>magnitude</span> <span class='op'>=</span> (<span class='self'>self</span>.<span class='ident'>x</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>x</span> <span class='op'>+</span> <span class='self'>self</span>.<span class='ident'>y</span> <span class='op'>*</span> <span class='self'>self</span>.<span class='ident'>y</span>) <span class='kw'>as</span> <span class='ident'>f64</span>;
        <span class='kw'>let</span> <span class='ident'>magnitude</span> <span class='op'>=</span> <span class='ident'>magnitude</span>.<span class='ident'>sqrt</span>();<span class='comment'>

        // Respect the formatting flags by using the helper method
        // `pad_integral` on the Formatter object. See the method documentation
        // for details, and the function `pad` can be used to pad strings.
        </span><span class='kw'>let</span> <span class='ident'>decimals</span> <span class='op'>=</span> <span class='ident'>f</span>.<span class='ident'>precision</span>.<span class='ident'>unwrap_or</span>(<span class='number'>3</span>);
        <span class='kw'>let</span> <span class='ident'>string</span> <span class='op'>=</span> <span class='ident'>f64</span>::<span class='ident'>to_str_exact</span>(<span class='ident'>magnitude</span>, <span class='ident'>decimals</span>);
        <span class='ident'>f</span>.<span class='ident'>pad_integral</span>(<span class='boolval'>true</span>, <span class='string'>&quot;&quot;</span>, <span class='ident'>string</span>.<span class='ident'>as_bytes</span>())
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>myvector</span> <span class='op'>=</span> <span class='ident'>Vector2D</span> { <span class='ident'>x</span>: <span class='number'>3</span>, <span class='ident'>y</span>: <span class='number'>4</span> };

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>myvector</span>);<span class='comment'>       // =&gt; &quot;(3, 4)&quot;
    </span><span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:10.3t}&quot;</span>, <span class='ident'>myvector</span>);<span class='comment'> // =&gt; &quot;     5.000&quot;
</span>}
</pre>

<h3 id="related-macros" class='section-header'><a
                           href="#related-macros">Related macros</a></h3>
<p>There are a number of related macros in the <code>format!</code> family. The ones that are
currently implemented are:</p>
<pre class='rust '>
<span class='macro'>format</span><span class='macro'>!</span><span class='comment'>      // described above
</span><span class='macro'>write</span><span class='macro'>!</span><span class='comment'>       // first argument is a &amp;mut io::Writer, the destination
</span><span class='macro'>writeln</span><span class='macro'>!</span><span class='comment'>     // same as write but appends a newline
</span><span class='macro'>print</span><span class='macro'>!</span><span class='comment'>       // the format string is printed to the standard output
</span><span class='macro'>println</span><span class='macro'>!</span><span class='comment'>     // same as print but appends a newline
</span><span class='macro'>format_args</span><span class='macro'>!</span><span class='comment'> // described below.
</span></pre>

<h4 id="write!" class='section-header'><a
                           href="#write!"><code>write!</code></a></h4>
<p>This and <code>writeln</code> are two macros which are used to emit the format string to a
specified stream. This is used to prevent intermediate allocations of format
strings and instead directly write the output. Under the hood, this function is
actually invoking the <code>write</code> function defined in this module. Example usage is:</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>w</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>MemWriter</span>::<span class='ident'>new</span>();
<span class='macro'>write</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>w</span> <span class='kw'>as</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>io</span>::<span class='ident'>Writer</span>, <span class='string'>&quot;Hello {}!&quot;</span>, <span class='string'>&quot;world&quot;</span>);
</pre>

<h4 id="print!" class='section-header'><a
                           href="#print!"><code>print!</code></a></h4>
<p>This and <code>println</code> emit their output to stdout. Similarly to the <code>write!</code> macro,
the goal of these macros is to avoid intermediate allocations when printing
output. Example usage is:</p>
<pre class='rust '>
<span class='macro'>print</span><span class='macro'>!</span>(<span class='string'>&quot;Hello {}!&quot;</span>, <span class='string'>&quot;world&quot;</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;I have a newline {}&quot;</span>, <span class='string'>&quot;character at the end&quot;</span>);
</pre>

<h4 id="format_args!" class='section-header'><a
                           href="#format_args!"><code>format_args!</code></a></h4>
<p>This is a curious macro which is used to safely pass around
an opaque object describing the format string. This object
does not require any heap allocations to create, and it only
references information on the stack. Under the hood, all of
the related macros are implemented in terms of this. First
off, some example usage is:</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;

<span class='macro'>format_args</span><span class='macro'>!</span>(<span class='ident'>fmt</span>::<span class='ident'>format</span>, <span class='string'>&quot;this returns {}&quot;</span>, <span class='string'>&quot;~str&quot;</span>);

<span class='kw'>let</span> <span class='ident'>some_writer</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>io</span>::<span class='ident'>Writer</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>io</span>::<span class='ident'>stdout</span>();
<span class='macro'>format_args</span><span class='macro'>!</span>(<span class='op'>|</span><span class='ident'>args</span><span class='op'>|</span> { <span class='ident'>fmt</span>::<span class='ident'>write</span>(<span class='ident'>some_writer</span>, <span class='ident'>args</span>) }, <span class='string'>&quot;print with a {}&quot;</span>, <span class='string'>&quot;closure&quot;</span>);

<span class='kw'>fn</span> <span class='ident'>my_fmt_fn</span>(<span class='ident'>args</span>: <span class='kw-2'>&amp;</span><span class='ident'>fmt</span>::<span class='ident'>Arguments</span>) {
    <span class='ident'>fmt</span>::<span class='ident'>write</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>io</span>::<span class='ident'>stdout</span>(), <span class='ident'>args</span>);
}
<span class='macro'>format_args</span><span class='macro'>!</span>(<span class='ident'>my_fmt_fn</span>, <span class='string'>&quot;or a {} too&quot;</span>, <span class='string'>&quot;function&quot;</span>);
</pre>

<p>The first argument of the <code>format_args!</code> macro is a function (or closure) which
takes one argument of type <code>&amp;fmt::Arguments</code>. This structure can then be
passed to the <code>write</code> and <code>format</code> functions inside this module in order to
process the format string. The goal of this macro is to even further prevent
intermediate allocations when dealing formatting strings.</p>

<p>For example, a logging library could use the standard formatting syntax, but it
would internally pass around this structure until it has been determined where
output should go to.</p>

<p>It is unsafe to programmatically create an instance of <code>fmt::Arguments</code> because
the operations performed when executing a format string require the compile-time
checks provided by the compiler. The <code>format_args!</code> macro is the only method of
safely creating these structures, but they can be unsafely created with the
constructor provided.</p>

<h2 id="internationalization" class='section-header'><a
                           href="#internationalization">Internationalization</a></h2>
<p>The formatting syntax supported by the <code>format!</code> extension supports
internationalization by providing &quot;methods&quot; which execute various different
outputs depending on the input. The syntax and methods provided are similar to
other internationalization systems, so again nothing should seem alien.
Currently two methods are supported by this extension: &quot;select&quot; and &quot;plural&quot;.</p>

<p>Each method will execute one of a number of clauses, and then the value of the
clause will become what&#39;s the result of the argument&#39;s format. Inside of the
cases, nested argument strings may be provided, but all formatting arguments
must not be done through implicit positional means. All arguments inside of each
case of a method must be explicitly selected by their name or their integer
position.</p>

<p>Furthermore, whenever a case is running, the special character <code>#</code> can be used
to reference the string value of the argument which was selected upon. As an
example:</p>
<pre class='rust '>
<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{0, select, other{#}}&quot;</span>, <span class='string'>&quot;hello&quot;</span>);<span class='comment'> // =&gt; &quot;hello&quot;.to_owned()
</span></pre>

<p>This example is the equivalent of <code>{0:s}</code> essentially.</p>

<h3 id="select" class='section-header'><a
                           href="#select">Select</a></h3>
<p>The select method is a switch over a <code>&amp;str</code> parameter, and the parameter <em>must</em>
be of the type <code>&amp;str</code>. An example of the syntax is:</p>

<pre><code class="language-notrust">{0, select, male{...} female{...} other{...}}</code></pre>

<p>Breaking this down, the <code>0</code>-th argument is selected upon with the <code>select</code>
method, and then a number of cases follow. Each case is preceded by an
identifier which is the match-clause to execute the given arm. In this case,
there are two explicit cases, <code>male</code> and <code>female</code>. The case will be executed if
the string argument provided is an exact match to the case selected.</p>

<p>The <code>other</code> case is also a required case for all <code>select</code> methods. This arm will
be executed if none of the other arms matched the word being selected over.</p>

<h3 id="plural" class='section-header'><a
                           href="#plural">Plural</a></h3>
<p>The plural method is a switch statement over a <code>uint</code> parameter, and the
parameter <em>must</em> be a <code>uint</code>. A plural method in its full glory can be specified
as:</p>

<pre><code class="language-notrust">{0, plural, offset=1 =1{...} two{...} many{...} other{...}}</code></pre>

<p>To break this down, the first <code>0</code> indicates that this method is selecting over
the value of the first positional parameter to the format string. Next, the
<code>plural</code> method is being executed. An optionally-supplied <code>offset</code> is then given
which indicates a number to subtract from argument <code>0</code> when matching. This is
then followed by a list of cases.</p>

<p>Each case is allowed to supply a specific value to match upon with the syntax
<code>=N</code>. This case is executed if the value at argument <code>0</code> matches N exactly,
without taking the offset into account. A case may also be specified by one of
five keywords: <code>zero</code>, <code>one</code>, <code>two</code>, <code>few</code>, and <code>many</code>. These cases are matched
on after argument <code>0</code> has the offset taken into account. Currently the
definitions of <code>many</code> and <code>few</code> are hardcoded, but they are in theory defined by
the current locale.</p>

<p>Finally, all <code>plural</code> methods must have an <code>other</code> case supplied which will be
executed if none of the other cases match.</p>

<h2 id="syntax" class='section-header'><a
                           href="#syntax">Syntax</a></h2>
<p>The syntax for the formatting language used is drawn from other languages, so it
should not be too alien. Arguments are formatted with python-like syntax,
meaning that arguments are surrounded by <code>{}</code> instead of the C-like <code>%</code>. The
actual grammar for the formatting syntax is:</p>

<pre><code class="language-notrust">format_string := &lt;text&gt; [ format &lt;text&gt; ] *
format := &#39;{&#39; [ argument ] [ &#39;:&#39; format_spec ] [ &#39;,&#39; function_spec ] &#39;}&#39;
argument := integer | identifier

format_spec := [[fill]align][sign][&#39;#&#39;][0][width][&#39;.&#39; precision][type]
fill := character
align := &#39;&lt;&#39; | &#39;&gt;&#39;
sign := &#39;+&#39; | &#39;-&#39;
width := count
precision := count | &#39;*&#39;
type := identifier | &#39;&#39;
count := parameter | integer
parameter := integer &#39;$&#39;

function_spec := plural | select
select := &#39;select&#39; &#39;,&#39; ( identifier arm ) *
plural := &#39;plural&#39; &#39;,&#39; [ &#39;offset:&#39; integer ] ( selector arm ) *
selector := &#39;=&#39; integer | keyword
keyword := &#39;zero&#39; | &#39;one&#39; | &#39;two&#39; | &#39;few&#39; | &#39;many&#39; | &#39;other&#39;
arm := &#39;{&#39; format_string &#39;}&#39;</code></pre>

<h2 id="formatting-parameters" class='section-header'><a
                           href="#formatting-parameters">Formatting Parameters</a></h2>
<p>Each argument being formatted can be transformed by a number of formatting
parameters (corresponding to <code>format_spec</code> in the syntax above). These
parameters affect the string representation of what&#39;s being formatted. This
syntax draws heavily from Python&#39;s, so it may seem a bit familiar.</p>

<h3 id="fill/alignment" class='section-header'><a
                           href="#fill/alignment">Fill/Alignment</a></h3>
<p>The fill character is provided normally in conjunction with the <code>width</code>
parameter. This indicates that if the value being formatted is smaller than
<code>width</code> some extra characters will be printed around it. The extra characters
are specified by <code>fill</code>, and the alignment can be one of two options:</p>

<ul>
<li><code>&lt;</code> - the argument is left-aligned in <code>width</code> columns</li>
<li><code>&gt;</code> - the argument is right-aligned in <code>width</code> columns</li>
</ul>

<h3 id="sign/#/0" class='section-header'><a
                           href="#sign/#/0">Sign/#/0</a></h3>
<p>These can all be interpreted as flags for a particular formatter.</p>

<ul>
<li>&#39;+&#39; - This is intended for numeric types and indicates that the sign should
    always be printed. Positive signs are never printed by default, and the
    negative sign is only printed by default for the <code>Signed</code> trait. This
    flag indicates that the correct sign (+ or -) should always be printed.</li>
<li>&#39;-&#39; - Currently not used</li>
<li>&#39;#&#39; - This flag is indicates that the &quot;alternate&quot; form of printing should be
    used. By default, this only applies to the integer formatting traits and
    performs like:

<ul>
<li><code>x</code> - precedes the argument with a &quot;0x&quot;</li>
<li><code>X</code> - precedes the argument with a &quot;0x&quot;</li>
<li><code>t</code> - precedes the argument with a &quot;0b&quot;</li>
<li><code>o</code> - precedes the argument with a &quot;0o&quot;</li>
</ul></li>
<li>&#39;0&#39; - This is used to indicate for integer formats that the padding should
    both be done with a <code>0</code> character as well as be sign-aware. A format
    like <code>{:08d}</code> would yield <code>00000001</code> for the integer <code>1</code>, while the same
    format would yield <code>-0000001</code> for the integer <code>-1</code>. Notice that the
    negative version has one fewer zero than the positive version.</li>
</ul>

<h3 id="width" class='section-header'><a
                           href="#width">Width</a></h3>
<p>This is a parameter for the &quot;minimum width&quot; that the format should take up. If
the value&#39;s string does not fill up this many characters, then the padding
specified by fill/alignment will be used to take up the required space.</p>

<p>The default fill/alignment for non-numerics is a space and left-aligned. The
defaults for numeric formatters is also a space but with right-alignment. If the
&#39;0&#39; flag is specified for numerics, then the implicit fill character is &#39;0&#39;.</p>

<p>The value for the width can also be provided as a <code>uint</code> in the list of
parameters by using the <code>2$</code> syntax indicating that the second argument is a
<code>uint</code> specifying the width.</p>

<h3 id="precision" class='section-header'><a
                           href="#precision">Precision</a></h3>
<p>For non-numeric types, this can be considered a &quot;maximum width&quot;. If the
resulting string is longer than this width, then it is truncated down to this
many characters and only those are emitted.</p>

<p>For integral types, this has no meaning currently.</p>

<p>For floating-point types, this indicates how many digits after the decimal point
should be printed.</p>

<h2 id="escaping" class='section-header'><a
                           href="#escaping">Escaping</a></h2>
<p>The literal characters <code>{</code>, <code>}</code>, or <code>#</code> may be included in a string by
preceding them with the <code>\</code> character. Since <code>\</code> is already an
escape character in Rust strings, a string literal using this escape
will look like <code>&quot;\\{&quot;</code>.</p>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                    <tr>
                        <td><a class='struct' href='struct.Argument.html'
                               title='std::fmt::Argument'>Argument</a></td>
                        <td class='docblock short'><p>This struct represents the generic &quot;argument&quot; which is taken by the Xprintf
family of functions. It contains a function to format the given value. At
compile time it is ensured that the function and the value have the correct
types, and then this struct is used to canonicalize arguments to one type.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.Arguments.html'
                               title='std::fmt::Arguments'>Arguments</a></td>
                        <td class='docblock short'><p>This structure represents a safely precompiled version of a format string
and its arguments. This cannot be generated at runtime because it cannot
safely be done so, so no constructors are given and the fields are private
to prevent modification.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.Formatter.html'
                               title='std::fmt::Formatter'>Formatter</a></td>
                        <td class='docblock short'><p>A struct to represent both where to emit formatting strings to and how they
should be formatted. A mutable version of this is passed to all formatting
traits.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.Radix.html'
                               title='std::fmt::Radix'>Radix</a></td>
                        <td class='docblock short'><p>A radix with in the range of <code>2..36</code>.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.RadixFmt.html'
                               title='std::fmt::RadixFmt'>RadixFmt</a></td>
                        <td class='docblock short'><p>A helper type for formatting radixes.</p>
</td>
                    </tr>
                </table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                    <tr>
                        <td><a class='trait' href='trait.Binary.html'
                               title='std::fmt::Binary'>Binary</a></td>
                        <td class='docblock short'><p>Format trait for the <code>t</code> character</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.Bool.html'
                               title='std::fmt::Bool'>Bool</a></td>
                        <td class='docblock short'><p>Format trait for the <code>b</code> character</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.Char.html'
                               title='std::fmt::Char'>Char</a></td>
                        <td class='docblock short'><p>Format trait for the <code>c</code> character</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.Float.html'
                               title='std::fmt::Float'>Float</a></td>
                        <td class='docblock short'><p>Format trait for the <code>f</code> character</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.LowerExp.html'
                               title='std::fmt::LowerExp'>LowerExp</a></td>
                        <td class='docblock short'><p>Format trait for the <code>e</code> character</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.LowerHex.html'
                               title='std::fmt::LowerHex'>LowerHex</a></td>
                        <td class='docblock short'><p>Format trait for the <code>x</code> character</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.Octal.html'
                               title='std::fmt::Octal'>Octal</a></td>
                        <td class='docblock short'><p>Format trait for the <code>o</code> character</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.Pointer.html'
                               title='std::fmt::Pointer'>Pointer</a></td>
                        <td class='docblock short'><p>Format trait for the <code>p</code> character</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.Poly.html'
                               title='std::fmt::Poly'>Poly</a></td>
                        <td class='docblock short'><p>Format trait for the <code>?</code> character</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.Show.html'
                               title='std::fmt::Show'>Show</a></td>
                        <td class='docblock short'><p>When a format is not otherwise specified, types are formatted by ascribing
to this trait. There is not an explicit way of selecting this trait to be
used for formatting, it is only if no other format is specified.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.Signed.html'
                               title='std::fmt::Signed'>Signed</a></td>
                        <td class='docblock short'><p>Format trait for the <code>i</code> and <code>d</code> characters</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.String.html'
                               title='std::fmt::String'>String</a></td>
                        <td class='docblock short'><p>Format trait for the <code>s</code> character</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.Unsigned.html'
                               title='std::fmt::Unsigned'>Unsigned</a></td>
                        <td class='docblock short'><p>Format trait for the <code>u</code> character</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.UpperExp.html'
                               title='std::fmt::UpperExp'>UpperExp</a></td>
                        <td class='docblock short'><p>Format trait for the <code>E</code> character</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='trait' href='trait.UpperHex.html'
                               title='std::fmt::UpperHex'>UpperHex</a></td>
                        <td class='docblock short'><p>Format trait for the <code>X</code> character</p>
</td>
                    </tr>
                </table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                    <tr>
                        <td><a class='fn' href='fn.format.html'
                               title='std::fmt::format'>format</a></td>
                        <td class='docblock short'><p>The format function takes a precompiled format string and a list of
arguments, to return the resulting formatted string.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.format_unsafe.html'
                               title='std::fmt::format_unsafe'>format_unsafe</a></td>
                        <td class='docblock short'><p>The unsafe version of the formatting function.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.radix.html'
                               title='std::fmt::radix'>radix</a></td>
                        <td class='docblock short'><p>Constructs a radix formatter in the range of <code>2..36</code>.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.write.html'
                               title='std::fmt::write'>write</a></td>
                        <td class='docblock short'><p>The <code>write</code> function takes an output stream, a precompiled format string,
and a list of arguments. The arguments will be formatted according to the
specified format string into the output stream provided.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.write_unsafe.html'
                               title='std::fmt::write_unsafe'>write_unsafe</a></td>
                        <td class='docblock short'><p>The <code>write_unsafe</code> function takes an output stream, a precompiled format
string, and a list of arguments. The arguments will be formatted according
to the specified format string into the output stream provided.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.writeln.html'
                               title='std::fmt::writeln'>writeln</a></td>
                        <td class='docblock short'><p>The <code>writeln</code> function takes the same arguments as <code>write</code>, except that it
will also write a newline (<code>\n</code>) character at the end of the format string.</p>
</td>
                    </tr>
                </table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table>
                    <tr>
                        <td><a class='type' href='type.Result.html'
                               title='std::fmt::Result'>Result</a></td>
                        <td class='docblock short'></td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    <script>
        var rootPath = "../../";
        var currentCrate = "std";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>