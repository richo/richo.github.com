<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The std library documentation.">

    <title>std::comm - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,600'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico">
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <section class="sidebar">
        
            <a href='../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        

        <p class='location'><a href='../index.html'>std</a></p><div class='block mod'><h2>Modules</h2><a class='mod ' href='../ascii/index.html'>ascii</a><br/><a class='mod ' href='../bitflags/index.html'>bitflags</a><br/><a class='mod ' href='../c_str/index.html'>c_str</a><br/><a class='mod ' href='../c_vec/index.html'>c_vec</a><br/><a class='mod current' href='../comm/index.html'>comm</a><br/><a class='mod ' href='../f32/index.html'>f32</a><br/><a class='mod ' href='../f64/index.html'>f64</a><br/><a class='mod ' href='../fmt/index.html'>fmt</a><br/><a class='mod ' href='../from_str/index.html'>from_str</a><br/><a class='mod ' href='../gc/index.html'>gc</a><br/><a class='mod ' href='../hash/index.html'>hash</a><br/><a class='mod ' href='../i16/index.html'>i16</a><br/><a class='mod ' href='../i32/index.html'>i32</a><br/><a class='mod ' href='../i64/index.html'>i64</a><br/><a class='mod ' href='../i8/index.html'>i8</a><br/><a class='mod ' href='../int/index.html'>int</a><br/><a class='mod ' href='../io/index.html'>io</a><br/><a class='mod ' href='../local_data/index.html'>local_data</a><br/><a class='mod ' href='../macros/index.html'>macros</a><br/><a class='mod ' href='../num/index.html'>num</a><br/><a class='mod ' href='../option/index.html'>option</a><br/><a class='mod ' href='../os/index.html'>os</a><br/><a class='mod ' href='../path/index.html'>path</a><br/><a class='mod ' href='../prelude/index.html'>prelude</a><br/><a class='mod ' href='../rc/index.html'>rc</a><br/><a class='mod ' href='../reflect/index.html'>reflect</a><br/><a class='mod ' href='../repr/index.html'>repr</a><br/><a class='mod ' href='../result/index.html'>result</a><br/><a class='mod ' href='../rt/index.html'>rt</a><br/><a class='mod ' href='../slice/index.html'>slice</a><br/><a class='mod ' href='../str/index.html'>str</a><br/><a class='mod ' href='../strbuf/index.html'>strbuf</a><br/><a class='mod ' href='../sync/index.html'>sync</a><br/><a class='mod ' href='../task/index.html'>task</a><br/><a class='mod ' href='../to_str/index.html'>to_str</a><br/><a class='mod ' href='../u16/index.html'>u16</a><br/><a class='mod ' href='../u32/index.html'>u32</a><br/><a class='mod ' href='../u64/index.html'>u64</a><br/><a class='mod ' href='../u8/index.html'>u8</a><br/><a class='mod ' href='../uint/index.html'>uint</a><br/><a class='mod ' href='../vec/index.html'>vec</a><br/></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Search documentation..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'>Module <a href='../index.html'>std</a>::<a class='mod' href=''>comm</a><a class='source' href='../../src/std/src/libstd/comm/mod.rs.html#11-2026'>[src]</a></h1>
<div class='docblock'><p>Communication primitives for concurrent tasks</p>

<p>Rust makes it very difficult to share data among tasks to prevent race
conditions and to improve parallelism, but there is often a need for
communication between concurrent tasks. The primitives defined in this
module are the building blocks for synchronization in rust.</p>

<p>This module provides message-based communication over channels, concretely
defined among three types:</p>

<ul>
<li><code>Sender</code></li>
<li><code>SyncSender</code></li>
<li><code>Receiver</code></li>
</ul>

<p>A <code>Sender</code> or <code>SyncSender</code> is used to send data to a <code>Receiver</code>. Both
senders are clone-able such that many tasks can send simultaneously to one
receiver.  These channels are <em>task blocking</em>, not <em>thread blocking</em>. This
means that if one task is blocked on a channel, other tasks can continue to
make progress.</p>

<p>Rust channels come in one of two flavors:</p>

<ol>
<li><p>An asynchronous, infinitely buffered channel. The <code>channel()</code> function
will return a <code>(Sender, Receiver)</code> tuple where all sends will be
<strong>asynchronous</strong> (they never block). The channel conceptually has an
infinite buffer.</p></li>
<li><p>A synchronous, bounded channel. The <code>sync_channel()</code> function will return
a <code>(SyncSender, Receiver)</code> tuple where the storage for pending messages
is a pre-allocated buffer of a fixed size. All sends will be
<strong>synchronous</strong> by blocking until there is buffer space available. Note
that a bound of 0 is allowed, causing the channel to become a
&quot;rendezvous&quot; channel where each sender atomically hands off a message to
a receiver.</p></li>
</ol>

<h2 id="failure-propagation" class='section-header'><a
                           href="#failure-propagation">Failure Propagation</a></h2>
<p>In addition to being a core primitive for communicating in rust, channels
are the points at which failure is propagated among tasks.  Whenever the one
half of channel is closed, the other half will have its next operation
<code>fail!</code>. The purpose of this is to allow propagation of failure among tasks
that are linked to one another via channels.</p>

<p>There are methods on both of senders and receivers to perform their
respective operations without failing, however.</p>

<h2 id="runtime-requirements" class='section-header'><a
                           href="#runtime-requirements">Runtime Requirements</a></h2>
<p>The channel types defined in this module generally have very few runtime
requirements in order to operate. The major requirement they have is for a
local rust <code>Task</code> to be available if any <em>blocking</em> operation is performed.</p>

<p>If a local <code>Task</code> is not available (for example an FFI callback), then the
<code>send</code> operation is safe on a <code>Sender</code> (as well as a <code>send_opt</code>) as well as
the <code>try_send</code> method on a <code>SyncSender</code>, but no other operations are
guaranteed to be safe.</p>

<p>Additionally, channels can interoperate between runtimes. If one task in a
program is running on libnative and another is running on libgreen, they can
still communicate with one another using channels.</p>

<h1 id="example" class='section-header'><a
                           href="#example">Example</a></h1>
<p>Simple usage:</p>
<pre class='rust '>
<span class='comment'>// Create a simple streaming channel
</span><span class='kw'>let</span> (<span class='ident'>tx</span>, <span class='ident'>rx</span>) <span class='op'>=</span> <span class='ident'>channel</span>();
<span class='ident'>spawn</span>(<span class='kw'>proc</span>() {
    <span class='ident'>tx</span>.<span class='ident'>send</span>(<span class='number'>10</span>);
});
<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>rx</span>.<span class='ident'>recv</span>(), <span class='number'>10</span>);
</pre>

<p>Shared usage:</p>
<pre class='rust '>
<span class='comment'>// Create a shared channel which can be sent along from many tasks
</span><span class='kw'>let</span> (<span class='ident'>tx</span>, <span class='ident'>rx</span>) <span class='op'>=</span> <span class='ident'>channel</span>();
<span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='ident'>range</span>(<span class='number'>0</span>, <span class='number'>10</span>) {
    <span class='kw'>let</span> <span class='ident'>tx</span> <span class='op'>=</span> <span class='ident'>tx</span>.<span class='ident'>clone</span>();
    <span class='ident'>spawn</span>(<span class='kw'>proc</span>() {
        <span class='ident'>tx</span>.<span class='ident'>send</span>(<span class='ident'>i</span>);
    })
}

<span class='kw'>for</span> _ <span class='kw'>in</span> <span class='ident'>range</span>(<span class='number'>0</span>, <span class='number'>10</span>) {
    <span class='kw'>let</span> <span class='ident'>j</span> <span class='op'>=</span> <span class='ident'>rx</span>.<span class='ident'>recv</span>();
    <span class='macro'>assert</span><span class='macro'>!</span>(<span class='number'>0</span> <span class='op'>&lt;=</span> <span class='ident'>j</span> <span class='op'>&amp;&amp;</span> <span class='ident'>j</span> <span class='op'>&lt;</span> <span class='number'>10</span>);
}
</pre>

<p>Propagating failure:</p>
<pre class='rust '>
<span class='comment'>// The call to recv() will fail!() because the channel has already hung
// up (or been deallocated)
</span><span class='kw'>let</span> (<span class='ident'>tx</span>, <span class='ident'>rx</span>) <span class='op'>=</span> <span class='ident'>channel</span>::<span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span>();
<span class='ident'>drop</span>(<span class='ident'>tx</span>);
<span class='ident'>rx</span>.<span class='ident'>recv</span>();
</pre>

<p>Synchronous channels:</p>
<pre class='rust '>
<span class='kw'>let</span> (<span class='ident'>tx</span>, <span class='ident'>rx</span>) <span class='op'>=</span> <span class='ident'>sync_channel</span>(<span class='number'>0</span>);
<span class='ident'>spawn</span>(<span class='kw'>proc</span>() {<span class='comment'>
    // This will wait for the parent task to start receiving
    </span><span class='ident'>tx</span>.<span class='ident'>send</span>(<span class='number'>53</span>);
});
<span class='ident'>rx</span>.<span class='ident'>recv</span>();
</pre>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                    <tr>
                        <td><a class='struct' href='struct.Handle.html'
                               title='std::comm::Handle'>Handle</a></td>
                        <td class='docblock short'><p>A handle to a receiver which is currently a member of a <code>Select</code> set of
receivers.  This handle is used to keep the receiver in the set as well as
interact with the underlying receiver.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.Messages.html'
                               title='std::comm::Messages'>Messages</a></td>
                        <td class='docblock short'><p>An iterator over messages on a receiver, this iterator will block
whenever <code>next</code> is called, waiting for a new message, and <code>None</code> will be
returned when the corresponding channel has hung up.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.Receiver.html'
                               title='std::comm::Receiver'>Receiver</a></td>
                        <td class='docblock short'><p>The receiving-half of Rust&#39;s channel type. This half can only be owned by
one task</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.Select.html'
                               title='std::comm::Select'>Select</a></td>
                        <td class='docblock short'><p>The &quot;receiver set&quot; of the select interface. This structure is used to manage
a set of receivers which are being selected over.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.Sender.html'
                               title='std::comm::Sender'>Sender</a></td>
                        <td class='docblock short'><p>The sending-half of Rust&#39;s asynchronous channel type. This half can only be
owned by one task, but it can be cloned to send to other tasks.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='struct' href='struct.SyncSender.html'
                               title='std::comm::SyncSender'>SyncSender</a></td>
                        <td class='docblock short'><p>The sending-half of Rust&#39;s synchronous channel type. This half can only be
owned by one task, but it can be cloned to send to other tasks.</p>
</td>
                    </tr>
                </table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                    <tr>
                        <td><a class='type' href='type.TryRecvError.html'
                               title='std::comm::TryRecvError'>TryRecvError</a></td>
                        <td class='docblock short'><p>This enumeration is the list of the possible reasons that try_recv could not
return data when called.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='type' href='type.TrySendError.html'
                               title='std::comm::TrySendError'>TrySendError</a></td>
                        <td class='docblock short'><p>This enumeration is the list of the possible error outcomes for the
<code>SyncSender::try_send</code> method.</p>
</td>
                    </tr>
                </table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                    <tr>
                        <td><a class='fn' href='fn.channel.html'
                               title='std::comm::channel'>channel</a></td>
                        <td class='docblock short'><p>Creates a new asynchronous channel, returning the sender/receiver halves.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='fn' href='fn.sync_channel.html'
                               title='std::comm::sync_channel'>sync_channel</a></td>
                        <td class='docblock short'><p>Creates a new synchronous, bounded channel.</p>
</td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&uarr;</dt>
                <dd>Move up in search results</dd>
                <dt>&darr;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    <script>
        var rootPath = "../../";
        var currentCrate = "std";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>